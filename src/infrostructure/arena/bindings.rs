#![cfg(not(doctest))]
#![allow(unused)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
/* automatically generated by rust-bindgen 0.71.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const AC_INFINITE: i32 = -1;
pub const PFNC_Mono1p: u32 = 16842807;
pub const PFNC_Mono2p: u32 = 16908344;
pub const PFNC_Mono4p: u32 = 17039417;
pub const PFNC_Mono8: u32 = 17301505;
pub const PFNC_Mono8s: u32 = 17301506;
pub const PFNC_Mono10: u32 = 17825795;
pub const PFNC_Mono10p: u32 = 17432646;
pub const PFNC_Mono12: u32 = 17825797;
pub const PFNC_Mono12p: u32 = 17563719;
pub const PFNC_Mono14: u32 = 17825829;
pub const PFNC_Mono16: u32 = 17825799;
pub const PFNC_BayerBG8: u32 = 17301515;
pub const PFNC_BayerBG10: u32 = 17825807;
pub const PFNC_BayerBG10p: u32 = 17432658;
pub const PFNC_BayerBG12: u32 = 17825811;
pub const PFNC_BayerBG12p: u32 = 17563731;
pub const PFNC_BayerBG16: u32 = 17825841;
pub const PFNC_BayerGB8: u32 = 17301514;
pub const PFNC_BayerGB10: u32 = 17825806;
pub const PFNC_BayerGB10p: u32 = 17432660;
pub const PFNC_BayerGB12: u32 = 17825810;
pub const PFNC_BayerGB12p: u32 = 17563733;
pub const PFNC_BayerGB16: u32 = 17825840;
pub const PFNC_BayerGR8: u32 = 17301512;
pub const PFNC_BayerGR10: u32 = 17825804;
pub const PFNC_BayerGR10p: u32 = 17432662;
pub const PFNC_BayerGR12: u32 = 17825808;
pub const PFNC_BayerGR12p: u32 = 17563735;
pub const PFNC_BayerGR16: u32 = 17825838;
pub const PFNC_BayerRG8: u32 = 17301513;
pub const PFNC_BayerRG10: u32 = 17825805;
pub const PFNC_BayerRG10p: u32 = 17432664;
pub const PFNC_BayerRG12: u32 = 17825809;
pub const PFNC_BayerRG12p: u32 = 17563737;
pub const PFNC_BayerRG16: u32 = 17825839;
pub const PFNC_RGBa8: u32 = 35651606;
pub const PFNC_RGBa10: u32 = 37748831;
pub const PFNC_RGBa10p: u32 = 36175968;
pub const PFNC_RGBa12: u32 = 37748833;
pub const PFNC_RGBa12p: u32 = 36700258;
pub const PFNC_RGBa14: u32 = 37748835;
pub const PFNC_RGBa16: u32 = 37748836;
pub const PFNC_RGB8: u32 = 35127316;
pub const PFNC_RGB8_Planar: u32 = 35127329;
pub const PFNC_RGB10: u32 = 36700184;
pub const PFNC_RGB10_Planar: u32 = 36700194;
pub const PFNC_RGB10p: u32 = 35520604;
pub const PFNC_RGB10p32: u32 = 35651613;
pub const PFNC_RGB12: u32 = 36700186;
pub const PFNC_RGB12_Planar: u32 = 36700195;
pub const PFNC_RGB12p: u32 = 35913821;
pub const PFNC_RGB14: u32 = 36700254;
pub const PFNC_RGB16: u32 = 36700211;
pub const PFNC_RGB16_Planar: u32 = 36700196;
pub const PFNC_RGB565p: u32 = 34603061;
pub const PFNC_BGRa8: u32 = 35651607;
pub const PFNC_BGRa10: u32 = 37748812;
pub const PFNC_BGRa10p: u32 = 36175949;
pub const PFNC_BGRa12: u32 = 37748814;
pub const PFNC_BGRa12p: u32 = 36700239;
pub const PFNC_BGRa14: u32 = 37748816;
pub const PFNC_BGRa16: u32 = 37748817;
pub const PFNC_BGR8: u32 = 35127317;
pub const PFNC_BGR10: u32 = 36700185;
pub const PFNC_BGR10p: u32 = 35520584;
pub const PFNC_BGR12: u32 = 36700187;
pub const PFNC_BGR12p: u32 = 35913801;
pub const PFNC_BGR14: u32 = 36700234;
pub const PFNC_BGR16: u32 = 36700235;
pub const PFNC_BGR565p: u32 = 34603062;
pub const PFNC_R8: u32 = 17301705;
pub const PFNC_R10: u32 = 17432778;
pub const PFNC_R12: u32 = 17563851;
pub const PFNC_R16: u32 = 17825996;
pub const PFNC_G8: u32 = 17301709;
pub const PFNC_G10: u32 = 17432782;
pub const PFNC_G12: u32 = 17563855;
pub const PFNC_G16: u32 = 17826000;
pub const PFNC_B8: u32 = 17301713;
pub const PFNC_B10: u32 = 17432786;
pub const PFNC_B12: u32 = 17563859;
pub const PFNC_B16: u32 = 17826004;
pub const PFNC_Coord3D_ABC8: u32 = 35127474;
pub const PFNC_Coord3D_ABC8_Planar: u32 = 35127475;
pub const PFNC_Coord3D_ABC10p: u32 = 35520731;
pub const PFNC_Coord3D_ABC10p_Planar: u32 = 35520732;
pub const PFNC_Coord3D_ABC12p: u32 = 35913950;
pub const PFNC_Coord3D_ABC12p_Planar: u32 = 35913951;
pub const PFNC_Coord3D_ABC16: u32 = 36700345;
pub const PFNC_Coord3D_ABC16_Planar: u32 = 36700346;
pub const PFNC_Coord3D_ABC32f: u32 = 39846080;
pub const PFNC_Coord3D_ABC32f_Planar: u32 = 39846081;
pub const PFNC_Coord3D_AC8: u32 = 34603188;
pub const PFNC_Coord3D_AC8_Planar: u32 = 34603189;
pub const PFNC_Coord3D_AC10p: u32 = 34865392;
pub const PFNC_Coord3D_AC10p_Planar: u32 = 34865393;
pub const PFNC_Coord3D_AC12p: u32 = 35127538;
pub const PFNC_Coord3D_AC12p_Planar: u32 = 35127539;
pub const PFNC_Coord3D_AC16: u32 = 35651771;
pub const PFNC_Coord3D_AC16_Planar: u32 = 35651772;
pub const PFNC_Coord3D_AC32f: u32 = 37748930;
pub const PFNC_Coord3D_AC32f_Planar: u32 = 37748931;
pub const PFNC_Coord3D_A8: u32 = 17301679;
pub const PFNC_Coord3D_A10p: u32 = 17432789;
pub const PFNC_Coord3D_A12p: u32 = 17563864;
pub const PFNC_Coord3D_A16: u32 = 17825974;
pub const PFNC_Coord3D_A32f: u32 = 18874557;
pub const PFNC_Coord3D_B8: u32 = 17301680;
pub const PFNC_Coord3D_B10p: u32 = 17432790;
pub const PFNC_Coord3D_B12p: u32 = 17563865;
pub const PFNC_Coord3D_B16: u32 = 17825975;
pub const PFNC_Coord3D_B32f: u32 = 18874558;
pub const PFNC_Coord3D_C8: u32 = 17301681;
pub const PFNC_Coord3D_C10p: u32 = 17432791;
pub const PFNC_Coord3D_C12p: u32 = 17563866;
pub const PFNC_Coord3D_C16: u32 = 17825976;
pub const PFNC_Coord3D_C32f: u32 = 18874559;
pub const PFNC_Confidence1: u32 = 17301700;
pub const PFNC_Confidence1p: u32 = 16842949;
pub const PFNC_Confidence8: u32 = 17301702;
pub const PFNC_Confidence16: u32 = 17825991;
pub const PFNC_Confidence32f: u32 = 18874568;
pub const PFNC_BiColorBGRG8: u32 = 34603174;
pub const PFNC_BiColorBGRG10: u32 = 35651753;
pub const PFNC_BiColorBGRG10p: u32 = 34865322;
pub const PFNC_BiColorBGRG12: u32 = 35651757;
pub const PFNC_BiColorBGRG12p: u32 = 35127470;
pub const PFNC_BiColorRGBG8: u32 = 34603173;
pub const PFNC_BiColorRGBG10: u32 = 35651751;
pub const PFNC_BiColorRGBG10p: u32 = 34865320;
pub const PFNC_BiColorRGBG12: u32 = 35651755;
pub const PFNC_BiColorRGBG12p: u32 = 35127468;
pub const PFNC_SCF1WBWG8: u32 = 17301607;
pub const PFNC_SCF1WBWG10: u32 = 17825896;
pub const PFNC_SCF1WBWG10p: u32 = 17432681;
pub const PFNC_SCF1WBWG12: u32 = 17825898;
pub const PFNC_SCF1WBWG12p: u32 = 17563755;
pub const PFNC_SCF1WBWG14: u32 = 17825900;
pub const PFNC_SCF1WBWG16: u32 = 17825901;
pub const PFNC_SCF1WGWB8: u32 = 17301614;
pub const PFNC_SCF1WGWB10: u32 = 17825903;
pub const PFNC_SCF1WGWB10p: u32 = 17432688;
pub const PFNC_SCF1WGWB12: u32 = 17825905;
pub const PFNC_SCF1WGWB12p: u32 = 17563762;
pub const PFNC_SCF1WGWB14: u32 = 17825907;
pub const PFNC_SCF1WGWB16: u32 = 17825908;
pub const PFNC_SCF1WGWR8: u32 = 17301621;
pub const PFNC_SCF1WGWR10: u32 = 17825910;
pub const PFNC_SCF1WGWR10p: u32 = 17432695;
pub const PFNC_SCF1WGWR12: u32 = 17825912;
pub const PFNC_SCF1WGWR12p: u32 = 17563769;
pub const PFNC_SCF1WGWR14: u32 = 17825914;
pub const PFNC_SCF1WGWR16: u32 = 17825915;
pub const PFNC_SCF1WRWG8: u32 = 17301628;
pub const PFNC_SCF1WRWG10: u32 = 17825917;
pub const PFNC_SCF1WRWG10p: u32 = 17432702;
pub const PFNC_SCF1WRWG12: u32 = 17825919;
pub const PFNC_SCF1WRWG12p: u32 = 17563776;
pub const PFNC_SCF1WRWG14: u32 = 17825921;
pub const PFNC_SCF1WRWG16: u32 = 17825922;
pub const PFNC_YCbCr8: u32 = 35127387;
pub const PFNC_YCbCr8_CbYCr: u32 = 35127354;
pub const PFNC_YCbCr10_CbYCr: u32 = 36700291;
pub const PFNC_YCbCr10p_CbYCr: u32 = 35520644;
pub const PFNC_YCbCr12_CbYCr: u32 = 36700293;
pub const PFNC_YCbCr12p_CbYCr: u32 = 35913862;
pub const PFNC_YCbCr411_8: u32 = 34340954;
pub const PFNC_YCbCr411_8_CbYYCrYY: u32 = 34340924;
pub const PFNC_YCbCr422_8: u32 = 34603067;
pub const PFNC_YCbCr422_8_CbYCrY: u32 = 34603075;
pub const PFNC_YCbCr422_10: u32 = 35651685;
pub const PFNC_YCbCr422_10_CbYCrY: u32 = 35651737;
pub const PFNC_YCbCr422_10p: u32 = 34865287;
pub const PFNC_YCbCr422_10p_CbYCrY: u32 = 34865306;
pub const PFNC_YCbCr422_12: u32 = 35651686;
pub const PFNC_YCbCr422_12_CbYCrY: u32 = 35651739;
pub const PFNC_YCbCr422_12p: u32 = 35127432;
pub const PFNC_YCbCr422_12p_CbYCrY: u32 = 35127452;
pub const PFNC_YCbCr601_8_CbYCr: u32 = 35127357;
pub const PFNC_YCbCr601_10_CbYCr: u32 = 36700297;
pub const PFNC_YCbCr601_10p_CbYCr: u32 = 35520650;
pub const PFNC_YCbCr601_12_CbYCr: u32 = 36700299;
pub const PFNC_YCbCr601_12p_CbYCr: u32 = 35913868;
pub const PFNC_YCbCr601_411_8_CbYYCrYY: u32 = 34340927;
pub const PFNC_YCbCr601_422_8: u32 = 34603070;
pub const PFNC_YCbCr601_422_8_CbYCrY: u32 = 34603076;
pub const PFNC_YCbCr601_422_10: u32 = 35651725;
pub const PFNC_YCbCr601_422_10_CbYCrY: u32 = 35651741;
pub const PFNC_YCbCr601_422_10p: u32 = 34865294;
pub const PFNC_YCbCr601_422_10p_CbYCrY: u32 = 34865310;
pub const PFNC_YCbCr601_422_12: u32 = 35651727;
pub const PFNC_YCbCr601_422_12_CbYCrY: u32 = 35651743;
pub const PFNC_YCbCr601_422_12p: u32 = 35127440;
pub const PFNC_YCbCr601_422_12p_CbYCrY: u32 = 35127456;
pub const PFNC_YCbCr709_8_CbYCr: u32 = 35127360;
pub const PFNC_YCbCr709_10_CbYCr: u32 = 36700305;
pub const PFNC_YCbCr709_10p_CbYCr: u32 = 35520658;
pub const PFNC_YCbCr709_12_CbYCr: u32 = 36700307;
pub const PFNC_YCbCr709_12p_CbYCr: u32 = 35913876;
pub const PFNC_YCbCr709_411_8_CbYYCrYY: u32 = 34340930;
pub const PFNC_YCbCr709_422_8: u32 = 34603073;
pub const PFNC_YCbCr709_422_8_CbYCrY: u32 = 34603077;
pub const PFNC_YCbCr709_422_10: u32 = 35651733;
pub const PFNC_YCbCr709_422_10_CbYCrY: u32 = 35651745;
pub const PFNC_YCbCr709_422_10p: u32 = 34865302;
pub const PFNC_YCbCr709_422_10p_CbYCrY: u32 = 34865314;
pub const PFNC_YCbCr709_422_12: u32 = 35651735;
pub const PFNC_YCbCr709_422_12_CbYCrY: u32 = 35651747;
pub const PFNC_YCbCr709_422_12p: u32 = 35127448;
pub const PFNC_YCbCr709_422_12p_CbYCrY: u32 = 35127460;
pub const PFNC_YCbCr2020_8_CbYCr: u32 = 35127540;
pub const PFNC_YCbCr2020_10_CbYCr: u32 = 36700405;
pub const PFNC_YCbCr2020_10p_CbYCr: u32 = 35520758;
pub const PFNC_YCbCr2020_12_CbYCr: u32 = 36700407;
pub const PFNC_YCbCr2020_12p_CbYCr: u32 = 35913976;
pub const PFNC_YCbCr2020_411_8_CbYYCrYY: u32 = 34341113;
pub const PFNC_YCbCr2020_422_8: u32 = 34603258;
pub const PFNC_YCbCr2020_422_8_CbYCrY: u32 = 34603259;
pub const PFNC_YCbCr2020_422_10: u32 = 35651836;
pub const PFNC_YCbCr2020_422_10_CbYCrY: u32 = 35651837;
pub const PFNC_YCbCr2020_422_10p: u32 = 34865406;
pub const PFNC_YCbCr2020_422_10p_CbYCrY: u32 = 34865407;
pub const PFNC_YCbCr2020_422_12: u32 = 35651840;
pub const PFNC_YCbCr2020_422_12_CbYCrY: u32 = 35651841;
pub const PFNC_YCbCr2020_422_12p: u32 = 35127554;
pub const PFNC_YCbCr2020_422_12p_CbYCrY: u32 = 35127555;
pub const PFNC_YUV8_UYV: u32 = 35127328;
pub const PFNC_YUV411_8_UYYVYY: u32 = 34340894;
pub const PFNC_YUV422_8: u32 = 34603058;
pub const PFNC_YUV422_8_UYVY: u32 = 34603039;
pub const GVSP_Mono10Packed: u32 = 17563652;
pub const GVSP_Mono12Packed: u32 = 17563654;
pub const GVSP_BayerBG10Packed: u32 = 17563689;
pub const GVSP_BayerBG12Packed: u32 = 17563693;
pub const GVSP_BayerGB10Packed: u32 = 17563688;
pub const GVSP_BayerGB12Packed: u32 = 17563692;
pub const GVSP_BayerGR10Packed: u32 = 17563686;
pub const GVSP_BayerGR12Packed: u32 = 17563690;
pub const GVSP_BayerRG10Packed: u32 = 17563687;
pub const GVSP_BayerRG12Packed: u32 = 17563691;
pub const GVSP_RGB10V1Packed: u32 = 35651612;
pub const GVSP_RGB12V1Packed: u32 = 35913780;
pub const LUCID_PolarizeMono8: u32 = 2164785153;
pub const LUCID_PolarizeMono12p: u32 = 2165047367;
pub const LUCID_PolarizeMono12Packed: u32 = 2165047302;
pub const LUCID_PolarizeMono12: u32 = 2165309448;
pub const LUCID_PolarizeMono16: u32 = 2165309447;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono8: u32 = 2183135247;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono12p: u32 = 2184183839;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono16: u32 = 2185232431;
pub const LUCID_PolarizedStokes_S0_S1_S2_Mono8: u32 = 2182611007;
pub const LUCID_PolarizedStokes_S0_S1_S2_Mono12p: u32 = 2183397455;
pub const LUCID_PolarizedStokes_S0_S1_S2_Mono16: u32 = 2184183903;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono8: u32 = 2183135343;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono12p: u32 = 2184183935;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono16: u32 = 2185232527;
pub const LUCID_PolarizedAolp_Mono8: u32 = 2164785375;
pub const LUCID_PolarizedAolp_Mono12p: u32 = 2165047535;
pub const LUCID_PolarizedDolp_Mono8: u32 = 2164785343;
pub const LUCID_PolarizedDolp_Mono12p: u32 = 2165047503;
pub const LUCID_PolarizedDolp_Mono16: u32 = 2853218986;
pub const LUCID_PolarizedDolpAolp_Mono8: u32 = 2182086815;
pub const LUCID_PolarizedDolpAolp_Mono12p: u32 = 2182611119;
pub const LUCID_Coord3D_ABCY16s: u32 = 2185233408;
pub const LUCID_Coord3D_ABC16s: u32 = 2184184833;
pub const LUCID_Coord3D_C16s: u32 = 2165310466;
pub const LUCID_Coord3D_ABCY16: u32 = 2185233411;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_BayerRG8: u32 = 2183135759;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_BayerRG12p: u32 = 2184184351;
pub const LUCID_PolarizedStokes_S0_S1_S2_BayerRG8: u32 = 2182611519;
pub const LUCID_PolarizedStokes_S0_S1_S2_BayerRG12p: u32 = 2183397967;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_BayerRG8: u32 = 2183135855;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_BayerRG12p: u32 = 2184184447;
pub const LUCID_PolarizedAolp_BayerRG8: u32 = 2164785887;
pub const LUCID_PolarizedAolp_BayerRG12p: u32 = 2165048047;
pub const LUCID_PolarizedDolp_BayerRG8: u32 = 2164785855;
pub const LUCID_PolarizedDolp_BayerRG12p: u32 = 2165048015;
pub const LUCID_PolarizedDolp_BayerRG16: u32 = 3138436027;
pub const LUCID_PolarizedDolpAolp_BayerRG8: u32 = 2182087327;
pub const LUCID_PolarizedDolpAolp_BayerRG12p: u32 = 2182611631;
pub const LUCID_Mono24: u32 = 2165835008;
pub const LUCID_BayerGR24: u32 = 2165835009;
pub const LUCID_BayerRG24: u32 = 2165835010;
pub const LUCID_BayerGB24: u32 = 2165835011;
pub const LUCID_BayerBG24: u32 = 2165835012;
pub const LUCID_RGB24: u32 = 2185757957;
pub const LUCID_BGR24: u32 = 2185757958;
pub const LUCID_YCbCr422_16_CbYCrY: u32 = 2183136519;
pub const LUCID_YCbCr422_24_CbYCrY: u32 = 2184185096;
pub const LUCID_YCbCr411_16_CbYYCrYY: u32 = 2182612233;
pub const LUCID_YCbCr411_24_CbYYCrYY: u32 = 2183398666;
pub const LUCID_PolarizedDolpAngle_Mono8: u32 = 2182086911;
pub const LUCID_PolarizedDolpAngle_Mono12p: u32 = 2182611215;
pub const LUCID_PolarizedDolpAngle_Mono16: u32 = 2183135519;
pub const LUCID_PolarizedDolpAngle_BayerRG8: u32 = 2182087423;
pub const LUCID_PolarizedDolpAngle_BayerRG12p: u32 = 2182611727;
pub const LUCID_PolarizedDolpAngle_BayerRG16: u32 = 2183136031;
pub const LUCID_Coord3D_C16Y8: u32 = 2182611972;
pub const LUCID_Coord3D_CY16: u32 = 2183136261;
pub const LUCID_QOI_Mono8: u32 = 2164787712;
pub const LUCID_QOI_BayerGR8: u32 = 2164787968;
pub const LUCID_QOI_BayerRG8: u32 = 2164787969;
pub const LUCID_QOI_BayerGB8: u32 = 2164787970;
pub const LUCID_QOI_BayerBG8: u32 = 2164787971;
pub const LUCID_QOI_RGB8: u32 = 2182613505;
pub const LUCID_QOI_BGR8: u32 = 2182613506;
pub const LUCID_QOI_YCbCr8: u32 = 2182613507;
pub const LUCID_QOI_YCbCr8_CbYCr: u32 = 2182613508;
pub const LUCID_DualMono8: u32 = 2164789249;
pub const LUCID_DualMono10: u32 = 2165313539;
pub const LUCID_DualMono10p: u32 = 2164920390;
pub const LUCID_DualMono10Packed: u32 = 2165051396;
pub const LUCID_DualMono12: u32 = 2165313541;
pub const LUCID_DualMono12p: u32 = 2165051463;
pub const LUCID_DualMono12Packed: u32 = 2165051398;
pub const LUCID_DualMono16: u32 = 2165313543;
pub const LUCID_DualBayerRG8: u32 = 2164789257;
pub const LUCID_DualBayerRG10: u32 = 2165313549;
pub const LUCID_DualBayerRG10p: u32 = 2164920408;
pub const LUCID_DualBayerRG10Packed: u32 = 2165051431;
pub const LUCID_DualBayerRG12: u32 = 2165313553;
pub const LUCID_DualBayerRG12p: u32 = 2165051481;
pub const LUCID_DualBayerRG12Packed: u32 = 2165051435;
pub const LUCID_DualBayerRG16: u32 = 2165313583;
pub const LUCID_DualBayerGR8: u32 = 2164789256;
pub const LUCID_DualBayerGR10: u32 = 2165313548;
pub const LUCID_DualBayerGR10p: u32 = 2164920406;
pub const LUCID_DualBayerGR10Packed: u32 = 2165051430;
pub const LUCID_DualBayerGR12: u32 = 2165313552;
pub const LUCID_DualBayerGR12p: u32 = 2165051479;
pub const LUCID_DualBayerGR12Packed: u32 = 2165051434;
pub const LUCID_DualBayerGR16: u32 = 2165313582;
pub const LUCID_DualBayerBG8: u32 = 2164789259;
pub const LUCID_DualBayerBG10: u32 = 2165313551;
pub const LUCID_DualBayerBG10p: u32 = 2164920402;
pub const LUCID_DualBayerBG10Packed: u32 = 2165051433;
pub const LUCID_DualBayerBG12: u32 = 2165313555;
pub const LUCID_DualBayerBG12p: u32 = 2165051475;
pub const LUCID_DualBayerBG12Packed: u32 = 2165051437;
pub const LUCID_DualBayerBG16: u32 = 2165313585;
pub const LUCID_DualBayerGB8: u32 = 2164789258;
pub const LUCID_DualBayerGB10: u32 = 2165313550;
pub const LUCID_DualBayerGB10p: u32 = 2164920404;
pub const LUCID_DualBayerGB10Packed: u32 = 2165051432;
pub const LUCID_DualBayerGB12: u32 = 2165313554;
pub const LUCID_DualBayerGB12p: u32 = 2165051477;
pub const LUCID_DualBayerGB12Packed: u32 = 2165051436;
pub const LUCID_DualBayerGB16: u32 = 2165313584;
pub const LUCID_QuadMono8: u32 = 2164797441;
pub const LUCID_QuadMono10: u32 = 2165321731;
pub const LUCID_QuadMono10p: u32 = 2164928582;
pub const LUCID_QuadMono10Packed: u32 = 2165059588;
pub const LUCID_QuadMono12: u32 = 2165321733;
pub const LUCID_QuadMono12p: u32 = 2165059655;
pub const LUCID_QuadMono12Packed: u32 = 2165059590;
pub const LUCID_QuadMono16: u32 = 2165321735;
pub const LUCID_QuadBayerRG8: u32 = 2164797449;
pub const LUCID_QuadBayerRG10: u32 = 2165321741;
pub const LUCID_QuadBayerRG10p: u32 = 2164928600;
pub const LUCID_QuadBayerRG10Packed: u32 = 2165059623;
pub const LUCID_QuadBayerRG12: u32 = 2165321745;
pub const LUCID_QuadBayerRG12p: u32 = 2165059673;
pub const LUCID_QuadBayerRG12Packed: u32 = 2165059627;
pub const LUCID_QuadBayerRG16: u32 = 2165321775;
pub const LUCID_QuadBayerGR8: u32 = 2164797448;
pub const LUCID_QuadBayerGR10: u32 = 2165321740;
pub const LUCID_QuadBayerGR10p: u32 = 2164928598;
pub const LUCID_QuadBayerGR10Packed: u32 = 2165059622;
pub const LUCID_QuadBayerGR12: u32 = 2165321744;
pub const LUCID_QuadBayerGR12p: u32 = 2165059671;
pub const LUCID_QuadBayerGR12Packed: u32 = 2165059626;
pub const LUCID_QuadBayerGR16: u32 = 2165321774;
pub const LUCID_QuadBayerBG8: u32 = 2164797451;
pub const LUCID_QuadBayerBG10: u32 = 2165321743;
pub const LUCID_QuadBayerBG10p: u32 = 2164928594;
pub const LUCID_QuadBayerBG10Packed: u32 = 2165059625;
pub const LUCID_QuadBayerBG12: u32 = 2165321747;
pub const LUCID_QuadBayerBG12p: u32 = 2165059667;
pub const LUCID_QuadBayerBG12Packed: u32 = 2165059629;
pub const LUCID_QuadBayerBG16: u32 = 2165321777;
pub const LUCID_QuadBayerGB8: u32 = 2164797450;
pub const LUCID_QuadBayerGB10: u32 = 2165321742;
pub const LUCID_QuadBayerGB10p: u32 = 2164928596;
pub const LUCID_QuadBayerGB10Packed: u32 = 2165059624;
pub const LUCID_QuadBayerGB12: u32 = 2165321746;
pub const LUCID_QuadBayerGB12p: u32 = 2165059669;
pub const LUCID_QuadBayerGB12Packed: u32 = 2165059628;
pub const LUCID_QuadBayerGB16: u32 = 2165321776;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono12: u32 = 2185232415;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono12: u32 = 2185232511;
pub const LUCID_PolarizedAolp_Mono12: u32 = 2165309679;
pub const LUCID_PolarizedDolp_Mono12: u32 = 2165309647;
pub const LUCID_PolarizedDolpAolp_Mono12: u32 = 2183135407;
pub const LUCID_Coord3D_ABCY8: u32 = 2183136259;
pub const LUCID_Coord3D_CY8: u32 = 2182087684;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_BayerRG12: u32 = 2185232927;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_BayerRG12: u32 = 2185233023;
pub const LUCID_PolarizedAolp_BayerRG12: u32 = 2165310191;
pub const LUCID_PolarizedDolp_BayerRG12: u32 = 2165310159;
pub const LUCID_PolarizedDolpAolp_BayerRG12: u32 = 2183135919;
pub const LUCID_YCbCr16_CbYCr: u32 = 2184185095;
pub const LUCID_YCbCr24_CbYCr: u32 = 2185757960;
pub const LUCID_DualMono8_2ch: u32 = 2165313537;
pub const LUCID_DualMono10_2ch: u32 = 2166362115;
pub const LUCID_DualMono12_2ch: u32 = 2166362117;
pub const LUCID_DualMono16_2ch: u32 = 2166362119;
pub const LUCID_DualBayerRG8_2ch: u32 = 2165313545;
pub const LUCID_DualBayerRG10_2ch: u32 = 2166362125;
pub const LUCID_DualBayerRG12_2ch: u32 = 2166362129;
pub const LUCID_DualBayerRG16_2ch: u32 = 2166362159;
pub const LUCID_DualBayerGR8_2ch: u32 = 2165313544;
pub const LUCID_DualBayerGR10_2ch: u32 = 2166362124;
pub const LUCID_DualBayerGR12_2ch: u32 = 2166362128;
pub const LUCID_DualBayerGR16_2ch: u32 = 2166362158;
pub const LUCID_DualBayerBG8_2ch: u32 = 2165313547;
pub const LUCID_DualBayerBG10_2ch: u32 = 2166362127;
pub const LUCID_DualBayerBG12_2ch: u32 = 2166362131;
pub const LUCID_DualBayerBG16_2ch: u32 = 2166362161;
pub const LUCID_DualBayerGB8_2ch: u32 = 2165313546;
pub const LUCID_DualBayerGB10_2ch: u32 = 2166362126;
pub const LUCID_DualBayerGB12_2ch: u32 = 2166362130;
pub const LUCID_DualBayerGB16_2ch: u32 = 2166362160;
pub const LUCID_QuadMono8_4ch: u32 = 2166370305;
pub const LUCID_QuadMono10_4ch: u32 = 2168467459;
pub const LUCID_QuadMono12_4ch: u32 = 2168467461;
pub const LUCID_QuadMono16_4ch: u32 = 2168467463;
pub const LUCID_QuadBayerRG8_4ch: u32 = 2166370313;
pub const LUCID_QuadBayerRG10_4ch: u32 = 2168467469;
pub const LUCID_QuadBayerRG12_4ch: u32 = 2168467473;
pub const LUCID_QuadBayerRG16_4ch: u32 = 2168467503;
pub const LUCID_QuadBayerGR8_4ch: u32 = 2166370312;
pub const LUCID_QuadBayerGR10_4ch: u32 = 2168467468;
pub const LUCID_QuadBayerGR12_4ch: u32 = 2168467472;
pub const LUCID_QuadBayerGR16_4ch: u32 = 2168467502;
pub const LUCID_QuadBayerBG8_4ch: u32 = 2166370315;
pub const LUCID_QuadBayerBG10_4ch: u32 = 2168467471;
pub const LUCID_QuadBayerBG12_4ch: u32 = 2168467475;
pub const LUCID_QuadBayerBG16_4ch: u32 = 2168467505;
pub const LUCID_QuadBayerGB8_4ch: u32 = 2166370314;
pub const LUCID_QuadBayerGB10_4ch: u32 = 2168467470;
pub const LUCID_QuadBayerGB12_4ch: u32 = 2168467474;
pub const LUCID_QuadBayerGB16_4ch: u32 = 2168467504;
pub const LUCID_LucidXYTP128f: u32 = 2189444438;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " @typedef acSystem;\n\n Representation of the system object, the entry point into Arena SDK."]
pub type acSystem = *mut ::std::os::raw::c_void;
#[doc = " @typedef acSocket;\n\n Representation of the socket object, the entry point into Arena SDK."]
pub type acSocket = *mut ::std::os::raw::c_void;
#[doc = " @typedef acDevice;\n\n Represents a device, used to configure and stream a device."]
pub type acDevice = *mut ::std::os::raw::c_void;
#[doc = " @typedef acBuffer;\n\n Represents a buffer, which carries a payload of either an image or a chunk\n data. A buffer can hold image data and/or chunk data."]
pub type acBuffer = *mut ::std::os::raw::c_void;
#[doc = " @typedef acFeatureStream;\n\n Represents a feature stream object, allowing node map configurations to be\n streamed to and from files."]
pub type acFeatureStream = *mut ::std::os::raw::c_void;
#[doc = " @typedef acNodeMap;\n\n Represents a node map, or feature tree."]
pub type acNodeMap = *mut ::std::os::raw::c_void;
#[doc = " @typedef acNode;\n\n Represents a node, or feature."]
pub type acNode = *mut ::std::os::raw::c_void;
#[doc = " @typedef acCallback;\n\n Represents a callback handle, used to deregister callbacks when they are no\n longer needed."]
pub type acCallback = *mut ::std::os::raw::c_void;
#[doc = " @typedef acFileStreamHandle;\n\n Represents a GenApi Input FileStream"]
pub type acIDevFileStream = *mut ::std::os::raw::c_void;
#[doc = " @typedef acFileStreamHandle;\n\n Represents a GenApi Output FileStream"]
pub type acODevFileStream = *mut ::std::os::raw::c_void;
pub type bool8_t = u8;
#[doc = " @typedef acCallbackFunction\n\n The signature of a function needed to register a callback. An example of\n such a function might look like the following.\n\n \\code{.c}\n \t// a function with the appropriate function signature to register as a callback\n \t// error handling skipped for brevity\n \t{\n \t\tvoid onCallback(acNode hNode, void* pUserData)\n \t\t{\n \t\t\tUserDataStruct* userData = reinterpret_cast<UserDataStruct*>(pUserData);\n\n \t\t\tchar pBuf[100];\n \t\t\tsize_t len = 100;\n \t\t\tacNodeGetName(hNode, pBuf, &len);\n \t\t\t// ...\n \t\t}\n \t}\n \\endcode"]
pub type acCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: acNode, arg2: *mut ::std::os::raw::c_void)>;
pub type acImageCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: acBuffer, arg2: *mut ::std::os::raw::c_void)>;
pub type acDeviceDisconnectCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: acDevice)>;
#[doc = "< Success, no error"]
pub const AC_ERROR_LIST_AC_ERR_SUCCESS: AC_ERROR_LIST = 0;
#[doc = "< Generic error"]
pub const AC_ERROR_LIST_AC_ERR_ERROR: AC_ERROR_LIST = -1001;
#[doc = "< Arena SDK not initialized"]
pub const AC_ERROR_LIST_AC_ERR_NOT_INITIALIZED: AC_ERROR_LIST = -1002;
#[doc = "< Function not implemented"]
pub const AC_ERROR_LIST_AC_ERR_NOT_IMPLEMENTED: AC_ERROR_LIST = -1003;
#[doc = "< Resource already in use"]
pub const AC_ERROR_LIST_AC_ERR_RESOURCE_IN_USE: AC_ERROR_LIST = -1004;
#[doc = "< Incorrect access"]
pub const AC_ERROR_LIST_AC_ERR_ACCESS_DENIED: AC_ERROR_LIST = -1005;
#[doc = "< Null/incorrect handle"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_HANDLE: AC_ERROR_LIST = -1006;
#[doc = "< Incorrect ID"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_ID: AC_ERROR_LIST = -1007;
#[doc = "< No data available"]
pub const AC_ERROR_LIST_AC_ERR_NO_DATA: AC_ERROR_LIST = -1008;
#[doc = "< Null/incorrect parameter"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_PARAMETER: AC_ERROR_LIST = -1009;
#[doc = "< Input/output error"]
pub const AC_ERROR_LIST_AC_ERR_IO: AC_ERROR_LIST = -1010;
#[doc = "< Timed out"]
pub const AC_ERROR_LIST_AC_ERR_TIMEOUT: AC_ERROR_LIST = -1011;
#[doc = "< Function aborted"]
pub const AC_ERROR_LIST_AC_ERR_ABORT: AC_ERROR_LIST = -1012;
#[doc = "< Invalid buffer"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_BUFFER: AC_ERROR_LIST = -1013;
#[doc = "< Function not available"]
pub const AC_ERROR_LIST_AC_ERR_NOT_AVAILABLE: AC_ERROR_LIST = -1014;
#[doc = "< Invalid register address"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_ADDRESS: AC_ERROR_LIST = -1015;
#[doc = "< Buffer too small"]
pub const AC_ERROR_LIST_AC_ERR_BUFFER_TOO_SMALL: AC_ERROR_LIST = -1016;
#[doc = "< Invalid index"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_INDEX: AC_ERROR_LIST = -1017;
#[doc = "< Error parsing chunk data"]
pub const AC_ERROR_LIST_AC_ERR_PARSING_CHUNK_DATA: AC_ERROR_LIST = -1018;
#[doc = "< Invalid value"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_VALUE: AC_ERROR_LIST = -1019;
#[doc = "< Resource cannot perform more actions"]
pub const AC_ERROR_LIST_AC_ERR_RESOURCE_EXHAUSTED: AC_ERROR_LIST = -1020;
#[doc = "< Not enough memory"]
pub const AC_ERROR_LIST_AC_ERR_OUT_OF_MEMORY: AC_ERROR_LIST = -1021;
#[doc = "< Busy on anothe process"]
pub const AC_ERROR_LIST_AC_ERR_BUSY: AC_ERROR_LIST = -1022;
#[doc = "< Start adding custom error LIST here"]
pub const AC_ERROR_LIST_AC_ERR_CUSTOM: AC_ERROR_LIST = -10000;
#[doc = " @enum AC_ERROR_LIST\n\n This enum represents the different errors that a function might return.\n\n @warning\n  - Use AC_ERROR integer values in place of AC_ERROR_LIST enum values"]
pub type AC_ERROR_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_ERROR;\n\n Integer representation of the error enum (AC_ERROR_LIST)."]
pub type AC_ERROR = i32;
#[doc = "< Not implemented"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_NI: AC_ACCESS_MODE_LIST = 0;
#[doc = "< Not available"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_NA: AC_ACCESS_MODE_LIST = 1;
#[doc = "< Write only"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_WO: AC_ACCESS_MODE_LIST = 2;
#[doc = "< Read only"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_RO: AC_ACCESS_MODE_LIST = 3;
#[doc = "< Read and write"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_RW: AC_ACCESS_MODE_LIST = 4;
#[doc = "< Undefined"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_UNDEFINED: AC_ACCESS_MODE_LIST = 5;
#[doc = " @enum AC_ACCESS_MODE_LIST\n\n This enum represents the different access modes for a device or its features.\n\n @warning\n  - Use AC_ACCESS_MODE integer values in place of AC_ACCESS_MODE_LIST enum\n    values"]
pub type AC_ACCESS_MODE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_ACCESS_MODE;\n\n Integer representation of the access mode enum (AC_ACCESS_MODE_LIST)."]
pub type AC_ACCESS_MODE = i32;
#[doc = "< Do not use cache"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_NO_CACHE: AC_CACHING_MODE_LIST = 0;
#[doc = "< Write to cache and register"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_WRITE_THROUGH: AC_CACHING_MODE_LIST = 1;
#[doc = "< Write to register, write to cache on read"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_WRITE_AROUND: AC_CACHING_MODE_LIST = 2;
#[doc = "< Undefined"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_UNDEFINED: AC_CACHING_MODE_LIST = 3;
#[doc = " @enum AC_CACHING_MODE_LIST\n\n This enum represents the different caching modes a node might use.\n\n @warning\n  - Use AC_CACHING_MODE integer values in place of AC_CACHING_MODE_LIST enum\n    values"]
pub type AC_CACHING_MODE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_CACHING_MODE;\n\n Integer representation of the caching mode enum (AC_CACHING_MODE_LIST)."]
pub type AC_CACHING_MODE = i32;
#[doc = "< Name resides in custom namespace"]
pub const AC_NAMESPACE_LIST_AC_NAMESPACE_CUSTOM: AC_NAMESPACE_LIST = 0;
#[doc = "< Name resides in one of the standard namespaces"]
pub const AC_NAMESPACE_LIST_AC_NAMESPACE_STANDARD: AC_NAMESPACE_LIST = 1;
#[doc = "< Undefined"]
pub const AC_NAMESPACE_LIST_AC_NAMESPACE_UNDEFINED: AC_NAMESPACE_LIST = 2;
#[doc = " @enum AC_NAMESPACE_LIST\n\n This enum represents whether a node is in the standard or custom namespaces.\n\n @warning\n  - Use AC_NAMESPACE integer values in place of AC_NAMESPACE_LIST enum values"]
pub type AC_NAMESPACE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_NAMESPACE;\n\n Integer representation of the namespace enum (AC_NAMESPACE_LIST)."]
pub type AC_NAMESPACE = i32;
#[doc = "< IValue interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_VALUE: AC_INTERFACE_TYPE_LIST = 0;
#[doc = "< IBase interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_BASE: AC_INTERFACE_TYPE_LIST = 1;
#[doc = "< IInteger interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_INTEGER: AC_INTERFACE_TYPE_LIST = 2;
#[doc = "< IBoolean interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_BOOLEAN: AC_INTERFACE_TYPE_LIST = 3;
#[doc = "< ICommand interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_COMMAND: AC_INTERFACE_TYPE_LIST = 4;
#[doc = "< IFloat interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_FLOAT: AC_INTERFACE_TYPE_LIST = 5;
#[doc = "< IString interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_STRING: AC_INTERFACE_TYPE_LIST = 6;
#[doc = "< IRegister interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_REGISTER: AC_INTERFACE_TYPE_LIST = 7;
#[doc = "< ICategory interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_CATEGORY: AC_INTERFACE_TYPE_LIST = 8;
#[doc = "< IEnumeration interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_ENUMERATION: AC_INTERFACE_TYPE_LIST = 9;
#[doc = "< IEnumEntry interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_ENUMENTRY: AC_INTERFACE_TYPE_LIST = 10;
#[doc = "< IPort interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_PORT: AC_INTERFACE_TYPE_LIST = 11;
#[doc = " @enum AC_INTERFACE_TYPE_LIST\n\n This enum represents the interface type of a node.\n\n @warning\n  - Use AC_INTERFACE_TYPE integer values in place of AC_INTERFACE_LIST enum\n    values"]
pub type AC_INTERFACE_TYPE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_INTERFACE_TYPE;\n\n Integer representation of the interface type enum (AC_INTERFACE_TYPE_LIST)."]
pub type AC_INTERFACE_TYPE = i32;
#[doc = "< Always visible"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_BEGINNER: AC_VISIBILITY_LIST = 0;
#[doc = "< Visible for experts or gurus"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_EXPERT: AC_VISIBILITY_LIST = 1;
#[doc = "< Visible for gurus"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_GURU: AC_VISIBILITY_LIST = 2;
#[doc = "< Not visible"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_INVISIBLE: AC_VISIBILITY_LIST = 3;
#[doc = "< Undefined"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_UNDEFINED: AC_VISIBILITY_LIST = 99;
#[doc = " @enum AC_VISIBILITY_LIST\n\n This enum represents the different visibilities of a node.\n\n @warning\n  - Use AC_VISIBILITY integer values in place of AC_VISIBILITY_LIST enum\n    values"]
pub type AC_VISIBILITY_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_VISIBILITY;\n\n Integer representation of the visibility enum (AC_VISIBILITY_LIST)."]
pub type AC_VISIBILITY = i32;
#[doc = "< The feature has no increment"]
pub const AC_INC_MODE_LIST_AC_INC_MODE_NONE: AC_INC_MODE_LIST = 0;
#[doc = "< The feature has a fix increment"]
pub const AC_INC_MODE_LIST_AC_INC_MODE_FIXED: AC_INC_MODE_LIST = 1;
#[doc = "< The feature has a list of valid values"]
pub const AC_INC_MODE_LIST_AC_INC_MODE_LIST: AC_INC_MODE_LIST = 2;
#[doc = " @enum AC_INC_MODE_LIST\n\n This enum represents the different increment modes of an integer/float node.\n\n @warning\n  - Use AC_INC_MODE integer values in place of AC_INC_MODE_LIST enum values"]
pub type AC_INC_MODE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_INC_MODE;\n\n Integer representation of the increment mode enum (AC_INC_MODE_LIST)."]
pub type AC_INC_MODE = i32;
#[doc = "< Slider with linear behavior"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_LINEAR: AC_REPRESENTATION_LIST = 0;
#[doc = "< Slider with logarithmic behavior"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_LOGARITHMIC: AC_REPRESENTATION_LIST = 1;
#[doc = "< Check box"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_BOOLEAN: AC_REPRESENTATION_LIST = 2;
#[doc = "< Decimal number in an edit control"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_PURE_NUMBER: AC_REPRESENTATION_LIST = 3;
#[doc = "< Hex number in an edit control"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_HEX_NUMBER: AC_REPRESENTATION_LIST = 4;
#[doc = "< IP address"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_IPV4_ADDRESS: AC_REPRESENTATION_LIST = 5;
#[doc = "< MAC address"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_MAC_ADDRESS: AC_REPRESENTATION_LIST = 6;
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_UNDEFINED: AC_REPRESENTATION_LIST = 7;
#[doc = " @enum AC_REPRESENTATION_LIST\n\n This enum represents the different representations of an integer/float node.\n\n @warning\n  - Use AC_REPRESENTATION integer values in place of AC_REPRESENTATION_LIST\n    enum values"]
pub type AC_REPRESENTATION_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_REPRESENTATION;\n\n Integer representation of the numeric representation enum\n (AC_REPRESENTATION_LIST)."]
pub type AC_REPRESENTATION = i32;
#[doc = "< The notation if either scientific or fixed depending on what is shorter"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_AUTOMATIC: AC_DISPLAY_NOTATION_LIST = 0;
#[doc = "< The notation is fixed, e.g. 123.4"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_FIXED: AC_DISPLAY_NOTATION_LIST = 1;
#[doc = "< The notation is scientific, e.g. 1.234e2"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_SCIENTIFIC: AC_DISPLAY_NOTATION_LIST = 2;
#[doc = "< Undefined"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_UNDEFINED: AC_DISPLAY_NOTATION_LIST = 3;
#[doc = " @enum AC_DISPLAY_NOTATION_LIST\n\n This enum represents the best way to display a float node.\n\n @warning\n  - Use AC_DISPLAY_NOTATION integer values in place of\n    AC_DISPLAY_NOTATION_LIST enum values"]
pub type AC_DISPLAY_NOTATION_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_DISPLAY_NOTATION;\n\n Integer representation of the display notation enum\n (AC_DISPLAY_NOTATION_LIST)."]
pub type AC_DISPLAY_NOTATION = i32;
#[doc = "< Image data only"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_IMAGE: AC_PAYLOAD_TYPE_LIST = 1;
#[doc = "< Image data extended with chunk data"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK: AC_PAYLOAD_TYPE_LIST = 16385;
#[doc = "< Chunk data only; image data may be present as chunk"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_CHUNKDATA: AC_PAYLOAD_TYPE_LIST = 4;
#[doc = "< Compressed image data only"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_COMPRESSED_IMAGE: AC_PAYLOAD_TYPE_LIST = 1001;
#[doc = "< Compressed image data extended with chunk data"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_COMPRESSED_IMAGE_EXTENDED_CHUNK:
    AC_PAYLOAD_TYPE_LIST = 1002;
#[doc = " @enum AC_PAYLOAD_TYPE_LIST\n\n This enum represents the different payload types of a buffer.\n\n @warning\n  - Use AC_PAYLOAD_TYPE integer values in place of AC_PAYLOAD_LIST enum\n    values"]
pub type AC_PAYLOAD_TYPE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_PAYLOAD_TYPE;\n\n Integer representation of the payload type enum (AC_PAYLOAD_TYPE_LIST)."]
pub type AC_PAYLOAD_TYPE = i32;
#[doc = "< Unknown pixel endianness"]
pub const AC_PIXEL_ENDIANNESS_LIST_AC_PIXEL_ENDIANNESS_UNKNOWN: AC_PIXEL_ENDIANNESS_LIST = 0;
#[doc = "< Little endian"]
pub const AC_PIXEL_ENDIANNESS_LIST_AC_PIXEL_ENDIANNESS_LITTLE: AC_PIXEL_ENDIANNESS_LIST = 1;
#[doc = "< Big endian"]
pub const AC_PIXEL_ENDIANNESS_LIST_AC_PIXEL_ENDIANNESS_BIG: AC_PIXEL_ENDIANNESS_LIST = 2;
#[doc = " @enum AC_PIXEL_ENDIANNESS_LIST\n\n This enum represents the different pixel endiannesses.\n\n @warning\n  - Use AC_PIXEL_ENDIANNESS integer values in place of\n    AC_PIXEL_ENDIANNESS_LIST enum values"]
pub type AC_PIXEL_ENDIANNESS_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_PIXEL_ENDIANNESS;\n\n Integer representation of the pixel endianness enum\n (AC_PIXEL_ENDIANNESS_LIST)."]
pub type AC_PIXEL_ENDIANNESS = i32;
#[doc = "< Algorithm that averages nearest neighbours (faster)"]
pub const AC_BAYER_ALGORITHM_LIST_AC_BAYER_ALGORITHM_DIRECTIONAL_INTERPOLATION:
    AC_BAYER_ALGORITHM_LIST = 0;
#[doc = "< Adaptive algorithm that uses directional data (slower, more accurate coloring)"]
pub const AC_BAYER_ALGORITHM_LIST_AC_BAYER_ALGORITHM_ADAPTIVE_HOMOGENEITY_DIRECTED:
    AC_BAYER_ALGORITHM_LIST = 1;
#[doc = "< Undefined algorithm"]
pub const AC_BAYER_ALGORITHM_LIST_AC_BAYER_ALGORITHM_UNKNOWN: AC_BAYER_ALGORITHM_LIST = 2;
#[doc = " @enum AC_BAYER_ALGORITHM_LIST\n\n This enum represents the different algorithms available to interpolate bayer\n image data.\n\n @warning\n  - Use AC_BAYER_ALGORITHM integer values in place of AC_BAYER_ALGORITHM_LIST\n    enum values"]
pub type AC_BAYER_ALGORITHM_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_BAYER_ALGORITHM;\n\n Integer representation of the bayer algorithm enum\n (AC_BAYER_ALGORITHM_LIST)."]
pub type AC_BAYER_ALGORITHM = i32;
#[doc = "< Default behavior for the underlying transport layer"]
pub const AC_START_STREAM_FLAGS_LIST_AC_START_STREAM_FLAG_DEFAULT: AC_START_STREAM_FLAGS_LIST = 1;
#[doc = "< Will try to start Gvsp 2.0 stream with 16bit block id if supported"]
pub const AC_START_STREAM_FLAGS_LIST_AC_START_STREAM_FLAG_GVSP_LEGACY: AC_START_STREAM_FLAGS_LIST =
    1001;
#[doc = " @enum AC_START_STREAM_FLAGS_LIST\n\n This enum represents the transport layer flags for starting a stream."]
pub type AC_START_STREAM_FLAGS_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_START_STREAM_FLAGS;\n\n Integer representation of the start stream flags\n (AC_START_STREAM_FLAGS_LIST)."]
pub type AC_START_STREAM_FLAGS = i32;
#[doc = "< Default open mode (out | trunc)"]
pub const AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST_AC_O_DEV_FILE_STREAM_OPEN_MODE_DEFAULT:
    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = 0;
#[doc = "< Open for output operations"]
pub const AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST_AC_O_DEV_FILE_STREAM_OPEN_MODE_OUT:
    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = 1;
#[doc = "< Open in binary mode"]
pub const AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST_AC_O_DEV_FILE_STREAM_OPEN_MODE_BINARY:
    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = 2;
#[doc = "< Truncate file if it exists"]
pub const AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST_AC_O_DEV_FILE_STREAM_OPEN_MODE_TRUNC:
    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = 4;
#[doc = "< Append mode"]
pub const AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST_AC_O_DEV_FILE_STREAM_OPEN_MODE_APPEND:
    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = 8;
#[doc = "< Open and seek to end immediately"]
pub const AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST_AC_O_DEV_FILE_STREAM_OPEN_MODE_ATE:
    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = 16;
#[doc = " @enum AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST\n\n This enum represents the open mode flags for the output device file stream.\n\n @warning\n  - Use AC_O_DEV_FILE_STREAM_OPEN_MODE integer values in place of\n    AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST enum values"]
pub type AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST = ::std::os::raw::c_uint;
#[doc = " @typedef AC_O_DEV_FILE_STREAM_OPEN_MODE;\n\n Integer representation of the open mode flags enum\n (AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST)."]
pub type AC_O_DEV_FILE_STREAM_OPEN_MODE = i32;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: usize,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: usize,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: usize,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: usize,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: usize,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acOpenSystem(acSystem* phSystem)\n\n @param phSystem\n  - Type: acSystem*\n  - [Out] parameter\n  - The system object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acOpenSystem </B> initializes the Arena SDK and retrieves the system\n object (acSystem). The system must be closed, or memory will leak.\n\n @see\n  - acSystem"]
    pub fn acOpenSystem(phSystem: *mut acSystem) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCloseSystem(acSystem hSystem)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCloseSystem </B> cleans up the system (acSystem) and deinitializes the\n Arena SDK, deallocating all memory.\n\n @see\n  - acSystem"]
    pub fn acCloseSystem(hSystem: acSystem) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " AC_ERROR acGetLastErrorMessage(char* pMessageBuf, size_t* pBufLen)\n\n @param pMessageBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Current value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acGetLastError </B> gets the most recent error from the current thread. If\n no errors have occurred in the thread, a \"No Error\" message is returned.\n"]
    pub fn acGetLastErrorMessage(
        pMessageBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acGetBitsPerPixel(uint64_t pixelFormat, size_t* pBitsPerPixel)\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format to get bits per pixel\n\n @param pBitsPerPixel\n  - Type: size_t*\n  - [Out] parameter\n  - Number of bits per pixel for given pixel format\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acGetBitsPerPixel </B> gets the number of bits per pixel of the image from\n the integer value of the pixel format (PfncFormat)."]
    pub fn acGetBitsPerPixel(pixelFormat: u64, pBitsPerPixel: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCalculateCRC32(const uint8_t* pData, size_t pDataLen, size_t* pCRCValue)\n\n @param pData\n  - Type: const uint8_t*\n  - [In] parameter\n  - A pointer to the data to use to calculate the CRC\n\n @param pDataLen\n  - Type: size_t\n  - [In] parameter\n  - The size of the data\n\n @param pCRCValue\n  - Type: size_t*\n  - [Out] parameter\n  - The calculated CRC value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCalculatedCRC32 </B> calculates a CRC value (cyclical redundancy check)\n on a dataset. This is used to check whether the dataset has been sent in its\n entirety."]
    pub fn acCalculateCRC32(pData: *const u8, pDataLen: usize, pCRCValue: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIsReadable(acNode hNode, bool8_t* pIsReadable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n\n @param pIsReadable\n  - Type: bool8_t*\n  - [Out] parameter\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIsReadable </B> checks whether a node is readable."]
    pub fn acIsReadable(hNode: acNode, pIsReadable: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIsWritable(acNode hNode, bool8_t* pIsWritable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n\n @param pIsWritable\n  - Type: bool8_t*\n  - [Out] parameter\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIsWritable </B> checks whether a node is writable."]
    pub fn acIsWritable(hNode: acNode, pIsWritable: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCalculateMaximumNumberOfBuffers(size_t payloadSize, size_t* pMaxBufs);\n\n @param payloadSize\n\t- Type: size_t\n\t- Unit: bytes\n\t- [In] parameter\n\t- Payload size of an image\n\n @param pMaxBufs\n\t- Type: size_t*\n\t- [Out] parameter\n\t- Maximum number of buffers\n\n @return\n\t- Type: AC_ERROR\n\t- Error code for the function\n\t- Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCalculateMaximumNumberOfBuffers </B> calculates the number of buffers it\n would take to fill 80% of the available memory."]
    pub fn acCalculateMaximumNumberOfBuffers(payloadSize: usize, pMaxBufs: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acGetVersion(char* pVersionBuf, size_t* pBufLen)\n\n @param pVersionBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Current value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acGetVersion </B> get build version"]
    pub fn acGetVersion(pVersionBuf: *mut ::std::os::raw::c_char, pBufLen: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetNumInterfaces(acSystem hSystem, size_t* pNumDevices)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pNumDevices\n  - Type: size_t*\n  - [Out] parameter\n  - The number of discovered interfaces\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetNumInterfaces </B> retrieves the number of discovered\n interfaces."]
    pub fn acSystemGetNumInterfaces(hSystem: acSystem, pNumDevices: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceIpAddress(acSystem hSystem, size_t index, uint32_t* pIpAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pIpAddress\n  - Type: uint32_t*\n  - [Out] parameter\n  - IP address as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceIpAddress </B> gets the IP address of an interface on\n the network, returning it as its raw integer value."]
    pub fn acSystemGetInterfaceIpAddress(
        hSystem: acSystem,
        index: usize,
        pIpAddress: *mut u32,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceIpAddressStr(acSystem hSystem, size_t index, char* pIpAddressStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pIpAddressStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - IP address as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceIpAddressStr </B> gets the IP address of an interface\n on the network, returning it as a string."]
    pub fn acSystemGetInterfaceIpAddressStr(
        hSystem: acSystem,
        index: usize,
        pIpAddressStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceSubnetMask(acSystem hSystem, size_t index, uint32_t* pSubnetMask)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pSubnetMask\n  - Type: uint32_t*\n  - [Out] parameter\n  - Subnet mask as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceSubnetMask </B> gets the subnet mask of an interface\n on the network, returning it as its raw integer value."]
    pub fn acSystemGetInterfaceSubnetMask(
        hSystem: acSystem,
        index: usize,
        pSubnetMask: *mut u32,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceSubnetMaskStr(acSystem hSystem, size_t index, char* pSubnetMaskStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pSubnetMaskStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Subnet mask as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceSubnetMaskStr </B> gets the subnet mask of an\n interface on the network, returning it as a string."]
    pub fn acSystemGetInterfaceSubnetMaskStr(
        hSystem: acSystem,
        index: usize,
        pSubnetMaskStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceMacAddress(acSystem hSystem, size_t index, uint64_t* pMacAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - MAC address as an integer\n\n @param pMacAddress\n  - Type: uint64_t*\n  - [Out] parameter\n  - MAC address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceMacAddress </B> gets the MAC address of an interface on\n the network, returning it as its raw integer value."]
    pub fn acSystemGetInterfaceMacAddress(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut u64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceMacAddressStr(acSystem hSystem, size_t index, char* pMacAddress, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pMacAddress\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - MAC address as a colon-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceMacAddressStr </B> gets the MAC address of an interface\n on the network, returning it as a string."]
    pub fn acSystemGetInterfaceMacAddressStr(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemUpdateDevices(acSystem hSystem, uint64_t timeout)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Time to wait for connected devices to respond\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemUpdateDevices </B> updates the internal list of devices, (along\n with their relevant interfaces). It must be called before retrieving the\n number of devices (acSystemGetNumDevices) or any time that an updated device\n list might be necessary.\n\n @see\n  - acSystemGetNumDevices"]
    pub fn acSystemUpdateDevices(hSystem: acSystem, timeout: u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemUpdateDevicesHasChanged(acSystem hSystem, uint64_t timeout, bool8_t* pHasChanged)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Time to wait for connected devices to respond\n\n @param pHasChanged\n  - Type: bool8_t*\n  - [Out] parameter\n  - True on first call that a device is found\n  - True if the device list has changed since the last call\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemUpdateDevicesHasChanged </B> updates the internal list of devices,\n (along with their relevant interfaces). It must be called before retrieving\n the number of devices (acSystemGetNumDevices) or any time that an updated\n device list might be necessary.\n\n @see\n  - acSystemGetNumDevices"]
    pub fn acSystemUpdateDevicesHasChanged(
        hSystem: acSystem,
        timeout: u64,
        pHasChanged: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemUpdateDevicesOnInterface(acSystem hSystem, size_t interfaceIndex, uint64_t timeout, bool8_t* pHasChanged)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param interfaceIndex\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Time to wait for connected devices to respond\n\n @param pHasChanged\n  - Type: bool8_t*\n  - [Out] parameter\n  - True on first call that a device is found\n  - True if the device list has changed since the last call\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemUpdateDevicesOnInterface </B> updates the internal list of\n devices, (along with their relevant interfaces). It must be called before\n retrieving the number of devices (acSystemGetNumDevices) or any time that an\n updated device list might be necessary.\n\n @see\n  - acSystemGetNumDevices"]
    pub fn acSystemUpdateDevicesOnInterface(
        hSystem: acSystem,
        interfaceIndex: usize,
        timeout: u64,
        pHasChanged: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemAddUnicastDiscoveryDevice(acSystem hSystem, char* pUnicastDeviceIP)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pUnicastDeviceIP\n  - Type: char*\n  - [In] parameter\n  - A pointer to a string containing an IP address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemAddUnicastDiscoveryDevice </B> registers an IP address for a device on a\n different subnet than the host. Registered devices will be enumerated\n using unicast discovery messages. The list of remote devices will\n persist until they are removed using RemoveUnicastDiscoveryDevice() or until\n the application terminates. Unicast discovery's will be sent when\n UpdateDevices() is called.\n\n @see\n  - acSystemRemoveUnicastDiscoveryDevice"]
    pub fn acSystemAddUnicastDiscoveryDevice(
        hSystem: acSystem,
        pUnicastDeviceIP: *mut ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemRemoveUnicastDiscoveryDevice(acSystem hSystem, char* pUnicastDeviceIP)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pUnicastDeviceIP\n  - Type: char*\n  - [In] parameter\n  - A pointer to a string containing an IP address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemRemoveUnicastDiscoveryDevice </B> unregisters an IP address for a device on a\n different subnet than the host. To remove all registered devices,\n pass NULL for the IP address argument.\n\n @see\n  - acSystemRemoveUnicastDiscoveryDevice"]
    pub fn acSystemRemoveUnicastDiscoveryDevice(
        hSystem: acSystem,
        pUnicastDeviceIP: *mut ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetNumDevices(acSystem hSystem, size_t* pNumDevices)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pNumDevices\n  - Type: size_t*\n  - [Out] parameter\n  - The number of discovered devices\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetNumDevices </B> retrieves the number of discovered devices. It\n must be called after updating the internal list of devices\n (acSystemUpdateDevices).\n\n @see\n  - acSystemUpdateDevices"]
    pub fn acSystemGetNumDevices(hSystem: acSystem, pNumDevices: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceModel(acSystem hSystem, size_t index, char* pModelNameBuf, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pModelNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Model name of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceModel </B> gets the model name of a device."]
    pub fn acSystemGetDeviceModel(
        hSystem: acSystem,
        index: usize,
        pModelNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceVendor(acSystem hSystem, size_t index, char* pVendorNameBuf, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pVendorNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Vendor name of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceVendor </B> gets the vendor/manufacturer name of a\n device. Vendor names differentiate between device vendors/manufacturers. Lucid\n devices return 'Lucid Vision Labs'."]
    pub fn acSystemGetDeviceVendor(
        hSystem: acSystem,
        index: usize,
        pVendorNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceSerial(acSystem hSystem, size_t index, char* pSerialNumberBuf, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pSerialNumberBuf\n  - Type: char*\n  - [Out] parameter\n  - Serial number of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetDeviceSerial </B> gets the serial number of a device. A serial\n number differentiates between devices. Each LUCID device has a unique serial\n number. LUCID serial numbers are numeric, but the serial numbers of other\n vendors may be alphanumeric."]
    pub fn acSystemGetDeviceSerial(
        hSystem: acSystem,
        index: usize,
        pSerialNumberBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceIpAddress(acSystem hSystem, size_t index, uint32_t* pIpAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIpAddress\n  - Type: uint32_t*\n  - [Out] parameter\n  - IP address as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceIpAddress </B> gets the IP address of a device on the\n network, returning it as its raw integer value."]
    pub fn acSystemGetDeviceIpAddress(
        hSystem: acSystem,
        index: usize,
        pIpAddress: *mut u32,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceIpAddressStr(acSystem hSystem, size_t index, char* pIpAddressStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIpAddressStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - IP address as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceIpAddressStr </B> gets the IP address of a device on the\n network, returning it as a string."]
    pub fn acSystemGetDeviceIpAddressStr(
        hSystem: acSystem,
        index: usize,
        pIpAddressStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceSubnetMask(acSystem hSystem, size_t index, uint32_t* pSubnetMask)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pSubnetMask\n  - Type: uint32_t*\n  - [Out] parameter\n  - Subnet mask as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceSubnetMask </B> gets the subnet mask of a device on the\n network, returning it as its raw integer value."]
    pub fn acSystemGetDeviceSubnetMask(
        hSystem: acSystem,
        index: usize,
        pSubnetMask: *mut u32,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceSubnetMaskStr(acSystem hSystem, size_t index, char* pSubnetMaskStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pSubnetMaskStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Subnet mask as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceSubnetMaskStr </B> gets the subnet mask of a device on\n the network, returning it as a string."]
    pub fn acSystemGetDeviceSubnetMaskStr(
        hSystem: acSystem,
        index: usize,
        pSubnetMaskStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceDefaultGateway(acSystem hSystem, size_t index, uint32_t* pDefaultGateway)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pDefaultGateway\n  - Type: uint32_t*\n  - [Out] parameter\n  - Default gateway as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemGetDeviceDefaultGateway(
        hSystem: acSystem,
        index: usize,
        pDefaultGateway: *mut u32,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceDefaultGatewayStr(acSystem hSystem, size_t index, char* pDefaultGatewayStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pDefaultGatewayStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Default gateway as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemGetDeviceDefaultGatewayStr(
        hSystem: acSystem,
        index: usize,
        pDefaultGatewayStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceMacAddress(acSystem hSystem, size_t index, uint64_t* pMacAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - MAC address as an integer\n\n @param pMacAddress\n  - Type: uint64_t*\n  - [Out] parameter\n  - MAC address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceMacAddress </B> gets the MAC address of a device on the\n network, returning it as its raw integer value."]
    pub fn acSystemGetDeviceMacAddress(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut u64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceMacAddressStr(acSystem hSystem, size_t index, char* pMacAddress, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pMacAddress\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - MAC address as a colon-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceMacAddressStr </B> gets the MAC address of a device on\n the network, returning it as a string."]
    pub fn acSystemGetDeviceMacAddressStr(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemForceIpAddress(acSystem hSystem, uint64_t macAddress, uint64_t ipAddress, uint64_t subnetMask, uint64_t defaultGateway)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param macAddress\n  - Type: uint64_t\n  - [In] parameter\n  - MAC address\n\n @param ipAddress\n  - Type: uint64_t\n  - [In] parameter\n  - Ip address\n\n @param subnetMask\n  - Type: uint64_t\n  - [In] parameter\n  - subnetMask address\n\n @param defaultGateway\n  - Type: uint64_t\n  - [In] parameter\n  - defaultGateway address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemForceIpAddress </B> force sets the IP address of a device on the\n network"]
    pub fn acSystemForceIpAddress(
        hSystem: acSystem,
        macAddress: u64,
        ipAddress: u64,
        subnetMask: u64,
        defaultGateway: u64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceUserDefinedName(acSystem hSystem, size_t index, char* pUserDefinedName, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pUserDefinedName\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - User-defined name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceUserDefinedName </B> gets the user-defined name of a\n device. If supported, it is a customizable string with a maximum of 16 bytes\n that can be used to identify a device."]
    pub fn acSystemGetDeviceUserDefinedName(
        hSystem: acSystem,
        index: usize,
        pUserDefinedName: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemIsDeviceDHCPConfigurationEnabled(acSystem hSystem, size_t index, bool8_t* pIsDHCPConfigurationEnabled)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIsDHCPConfigurationEnabled\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if DHCP enabled on device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemIsDeviceDHCPConfigurationEnabled(
        hSystem: acSystem,
        index: usize,
        pIsDHCPConfigurationEnabled: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemIsDevicePersistentIpConfigurationEnabled(acSystem hSystem, size_t index, bool8_t* pIsPersistentIpConfigurationEnabled)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIsPersistentIpConfigurationEnabled\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if persistent IP configuration set on device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemIsDevicePersistentIpConfigurationEnabled(
        hSystem: acSystem,
        index: usize,
        pIsPersistentIpConfigurationEnabled: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    pub fn acSystemGetDeviceVersion(
        hSystem: acSystem,
        index: usize,
        pDeviceVersion: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemIsDeviceLLAConfigurationEnabled(acSystem hSystem, size_t index, bool8_t* pIsLLAIpConfigurationEnabled)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIsLLAIpConfigurationEnabled\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if LLA enabled on device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemIsDeviceLLAConfigurationEnabled(
        hSystem: acSystem,
        index: usize,
        pIsLLAIpConfigurationEnabled: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemCreateDevice(acSystem hSystem, size_t index, acDevice* phDevice)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param phDevice\n  - Type: acDevice*\n  - [Out] parameter\n  - Initialized, ready-to-use device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemCreateDevice </B> creates and initializes a device. It must be\n called after the device list has been updated (acSystemUpdateDevices). The\n device must be destroyed (acSystemDestroyDevice) when no longer needed.\n\n @see\n  - acSystemUpdateDevices\n  - acSystemDestroyDevice"]
    pub fn acSystemCreateDevice(
        hSystem: acSystem,
        index: usize,
        phDevice: *mut acDevice,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemDestroyDevice(acSystem hSystem, acDevice hDevice)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - Device to destroy\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemDestroyDevice </B> destroys and cleans up the internal memory of a\n device (acDevice). Devices that have been created (acSystemCreateDevice) must\n be destroyed.\n\n @see\n  - acDevice\n  - acSystemCreateDevice"]
    pub fn acSystemDestroyDevice(hSystem: acSystem, hDevice: acDevice) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetTLSystemNodeMap(acSystem hSystem, acNodeMap* phNodeMap)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the system\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> GetTLSystemNodeMap </B> retrieves the GenTL system node map (acNodeMap),\n used to access system-related nodes (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acSystemGetTLSystemNodeMap(hSystem: acSystem, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemRegisterDeviceDisconnectCallback(acSystem hSystem, acDevice hDevice, acCallback* phDeviceDisconnectCallback, acDeviceDisconnectCallbackFunction callbackFn);\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device object\n\n @param phDeviceDisconnectCallback\n  - Type: acCallback*\n  - [Out] parameter\n  - Handle to registered acCallback\n\n @param callbackFn\n  - Type: acDeviceDisconnectCallbackFunction\n  - [In] parameter\n  - The device disconnect callback function to register\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemRegisterDeviceDisconnectCallback </B> registers a disconnect callback for specified device.\n When this device is disconnected, user-implemented OnDeviceDisconnected() will be called. The\n user-implemented OnDeviceDisconnected() will receive a handle to the device that was disconnected.\n\n @see\n  - acSystemDeregisterDeviceDisconnectCallback\n  - acSystemDeregisterAllDeviceDisconnectCallbacks"]
    pub fn acSystemRegisterDeviceDisconnectCallback(
        hSystem: acSystem,
        hDevice: acDevice,
        phDeviceDisconnectCallback: *mut acCallback,
        callbackFn: acDeviceDisconnectCallbackFunction,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemDeregisterDeviceDisconnectCallback(acSystem hSystem, acCallback hDeviceDisconnectCallback);\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param hDeviceDisconnectCallback\n  - Type: acCallback\n  - [In] parameter\n  - Device disconnect callback object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemDeregisterDeviceDisconnectCallback </B> unregisters a previously registered\n callback object. Callbacks can be unregistered whether or not the device is currently\n connected. To deregister all callbacks at once use acSystemDeregisterAllDeviceDisconnectCallbacks.\n\n @see\n  - acSystemRegisterDeviceDisconnectCallback\n  - acSystemDeregisterAllDeviceDisconnectCallbacks"]
    pub fn acSystemDeregisterDeviceDisconnectCallback(
        hSystem: acSystem,
        hDeviceDisconnectCallback: acCallback,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemDeregisterAllDeviceDisconnectCallbacks(acSystem hSystem);\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemDeregisterAllDeviceDisconnectCallbacks </B> deregisters all previously\n registered disconnect callback objects. Callbacks can be unregistered whether or\n not the device is currently connected. To deregister an individual\n callback see acSystemDeregisterDeviceDisconnectCallback.\n\n @see\n  - acSystemRegisterDeviceDisconnectCallback\n  - acSystemDeregisterDeviceDisconnectCallback"]
    pub fn acSystemDeregisterAllDeviceDisconnectCallbacks(hSystem: acSystem) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceStartStream(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceStartStream </B> causes the device to begin streaming image/chunk\n data (acBuffer). It must be called before image or chunk data buffers are\n retrieved (acDeviceGetBuffer). The stream must be stopped\n (acDeviceStopStream) when no longer needed.\n\n @see\n  - acBuffer\n  - acDeviceGetBuffer\n  - acDeviceStopStream"]
    pub fn acDeviceStartStream(hDevice: acDevice) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceStartStreamNumBuffersAndFlags(acDevice hDevice, size_t numBuffers)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param numBuffers\n  - Type: size_t\n  - [In] parameter\n  - Number of internal buffers to use in the acquisition engine\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceStartStreamNumBuffersAndFlags </B> causes the device to begin\n streaming image/chunk data (acBuffer) with given numBuffers and a streaming\n standard. It must be called before image or chunk data buffers are retrieved\n (acDeviceGetBuffer). The stream must be stopped (acDeviceStopStream) when no\n longer needed.\n\n @see\n  - acBuffer\n  - acDeviceGetBuffer\n  - acDeviceStopStream"]
    pub fn acDeviceStartStreamNumBuffersAndFlags(hDevice: acDevice, numBuffers: usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceStopStream(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceStopStream </B> stops the device from streaming image/chunk data\n (acBuffer) and cleans up the stream. The stream must be stopped when\n streaming is no longer needed.\n\n @see\n  - acBuffer"]
    pub fn acDeviceStopStream(hDevice: acDevice) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetBuffer(acDevice hDevice, uint64_t timeout, acBuffer* phBuffer)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Maximum time to wait for a buffer\n\n @param phBuffer\n  - Type: acBuffer*\n  - [Out] parameter\n  - Next buffer in the output queue\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetBuffer </B> retrieves a buffer (acBuffer) from the device. It\n must be called after the stream has started (acDeviceStartStream) and before\n the stream has stopped (acDeviceStopStream). Retrieved buffers must be\n requeued (acDeviceRequeueBuffer).\n\n @see\n  - acBuffer\n  - acDeviceStartStream\n  - acDeviceStopStream\n  - acDeviceRequeueBuffer"]
    pub fn acDeviceGetBuffer(hDevice: acDevice, timeout: u64, phBuffer: *mut acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceRequeueBuffer(acDevice hDevice, acBuffer pBuffer)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param pBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - Buffer to requeue\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceRequeueBuffer </B> relinquishes control of a buffer (acBuffer)\n back to Arena. It must be called after a buffer has been retrieved\n (acDeviceGetBuffer).\n\n @see\n  - acBuffer\n  - acDeviceGetBuffer"]
    pub fn acDeviceRequeueBuffer(hDevice: acDevice, pBuffer: acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceInitializeEvents(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceInitializeEvents </B> causes the underlying events engine to start\n listening for events. It must be called before waiting on events\n (acDeviceWaitOnEvent). The event infrastructure must be turned off\n (acDeviceDeinitializeEvents) when no longer needed.\n\n @see\n  - acDeviceWaitOnEvent\n  - acDeviceDeinitializeEvents"]
    pub fn acDeviceInitializeEvents(hDevice: acDevice) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceDeinitializeEvents(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceDeinitializeEvents </B> stops the underlying events engine from listening\n for messages, shutting it down and cleaning it up. It should be called only\n after the events infrastructure has been initialized\n (acDeviceInitializeEvents) and after all events have been processed\n (acDeviceWaitOnEvent).\n\n @see\n  - acDeviceInitializeEvents\n  - acDeviceWaitOnEvent"]
    pub fn acDeviceDeinitializeEvents(hDevice: acDevice) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceWaitOnEvent(acDevice hDevice, int64_t timeout)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Maximum time to wait for an event\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceWaitOnEvent </B> waits for an event to occur in order to process its data.\n It must be called after the event infrastructure has been initialized\n (acDeviceInitializeEvents) and before it is deinitialized\n (acDeviceDeinitializeEvents). This will also trigger callbacks registered to\n event nodes.\n\n @see\n  - acDeviceInitializeEvents\n  - acDeviceDeinitializeEvents"]
    pub fn acDeviceWaitOnEvent(hDevice: acDevice, timeout: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceIsConnected(acDevice hDevice, bool8_t* pIsConnected)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param pIsConnected\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the device is connected\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceIsConnected </B> returns true if a device has been opened and\n maintains a valid communication socket. The device is opened when\n acSystemCreateDevice is called. If the connection to the device\n is lost this will return false.\n\n More specifically, for GigE devices, this flag is set to false when\n the Arena is not able to refresh the heartbeat on the device. If an\n operation times out more than 3 times, the device will be flagged as\n not connected.\n\n @see\n  - acSystemCreateDevice"]
    pub fn acDeviceIsConnected(hDevice: acDevice, pIsConnected: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - Main node map for the device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetNodeMap </B> retrieves the already initialized main node map\n (acNodeMap), used to access a device's complete feature set of nodes\n (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetTLDeviceNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetTLDeviceNodeMap </B> retrieves the already initialized GenTL\n device node map (acNodeMap), used to access a subset of cached device related\n nodes (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetTLDeviceNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetTLStreamNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the stream\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetTLStreamNodeMap </B> retrieves the already initialized GenTL\n stream node map (acNodeMap), used to access stream-related nodes (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetTLStreamNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetTLInterfaceNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the interface\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetTLInterfaceNodeMap </B> retrieves the already initialized GenTL\n interface node map (acNodeMap), used to access interface related nodes\n (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetTLInterfaceNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceRegisterImageCallback(acDevice hDevice, acCallback* phCallback, acImageCallbackFunction callbackFn, void* pParam);\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phCallback\n  - Type: acCallback*\n  - [Out] parameter\n  - Handle to registered acCallback\n\n @param callbackFn\n  - Type: acImageCallbackFunction\n  - [In] parameter\n  - The image callback function to register\n\n @param pParam\n  - Type: void*\n  - [In] parameter\n  - Pointer to optional user-specified callback data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceRegisterImageCallback </B> registers the specified image callback\n function for the device. The optional user-specified data will be passed to\n the image callback function.\n\n @see\n  - acDeviceDeregisterImageCallback"]
    pub fn acDeviceRegisterImageCallback(
        hDevice: acDevice,
        phCallback: *mut acCallback,
        callbackFn: acImageCallbackFunction,
        pParam: *mut ::std::os::raw::c_void,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceDeregisterImageCallback(acDevice hDevice, acCallback* phCallback);\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phCallback\n  - Type: acCallback*\n  - [In] parameter\n  - Handle to registered acCallback\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceDeregisterImageCallback </B> deregisters the specified image\n callback for the device.\n\n @see\n  - acDeviceRegisterImageCallback"]
    pub fn acDeviceDeregisterImageCallback(
        hDevice: acDevice,
        phCallback: *mut acCallback,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceWaitForNextLeader(acDevice hDevice, int64_t timeout)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Maximum time to wait for next leader\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceWaitForNextLeader </B> will wait until the leader for the next image\n has arrived. It must be called after the stream has started\n (acDeviceStartStream) and before the stream has stopped\n (acDeviceStopStream).\n\n This function can be used to determine when the host has received the\n leader for the next image. Note that if the time that the camera has\n finished the exposure for the next image is desired, it is\n recommended to use the GenICam ExposureEnd Event instead.\n\n @see\n  - acDeviceResetWaitForNextLeader\n  - acDeviceStartStream\n  - acDeviceStopStream"]
    pub fn acDeviceWaitForNextLeader(hDevice: acDevice, timeout: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceResetWaitForNextLeader(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceResetWaitForNextLeader </B> clears any pending flag for a received leader event.\n\n @see\n  - acDeviceWaitForNextLeader\n  - acDeviceStartStream\n  - acDeviceStopStream"]
    pub fn acDeviceResetWaitForNextLeader(hDevice: acDevice) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetSizeFilled(acBuffer hBuffer, size_t* pSizeFilled)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pSizeFilled\n  - Type: size_t*\n  - [Out] parameter\n  - Size of the payload\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetSizeFilled </B> retrieves the size of the payload data,\n excluding transport layer protocol leaders. The payload data may include image\n data, chunk data, or both."]
    pub fn acBufferGetSizeFilled(hBuffer: acBuffer, pSizeFilled: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetPayloadSize(acBuffer hBuffer, size_t* pPayloadSize)\n\n @return\n  - Type: size_t\n  - Unit: bytes\n  - Size of the intended payload\n\n <B> GetPayloadSize </B> retrieves the intended size of the payload. This is\n similar to the retrieved payload size (acBufferGetSizeFilled), but different\n in that missed data is included.\n\n @warning\n  - Causes undefined behavior if buffer\n\n @see\n  - acBufferGetSizeFilled"]
    pub fn acBufferGetPayloadSize(hBuffer: acBuffer, pPayloadSize: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetSizeOfBuffer(acBuffer hBuffer, size_t* pSizeOfBuffer)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pSizeOfBuffer\n  - Type: size_t*\n  - [Out] parameter\n  - Size of the buffer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetSizeOfBuffer </B> retrieves the size of a buffer."]
    pub fn acBufferGetSizeOfBuffer(hBuffer: acBuffer, pSizeOfBuffer: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetFrameId(acBuffer hBuffer, uint64_t* pFrameId)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pFrameId\n  - Type: uint64_t*\n  - [Out] parameter\n  - Frame ID\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetFrameId </B> gets the frame ID, a sequential identifier for\n buffers."]
    pub fn acBufferGetFrameId(hBuffer: acBuffer, pFrameId: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetPayloadType(acBuffer hBuffer, AC_PAYLOAD_TYPE* pPayloadType)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pPayloadType\n  - Type: AC_PAYLOAD_TYPE*\n  - [Out] parameter\n  - Type of payload data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetPayloadType </B> returns a buffer's payload type\n (AC_PAYLOAD_TYPE), as defined by the GigE Vision specification."]
    pub fn acBufferGetPayloadType(
        hBuffer: acBuffer,
        pPayloadType: *mut AC_PAYLOAD_TYPE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferHasChunkData(acBuffer hBuffer, bool8_t* pHasChunkData)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pHasChunkData\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload has chunk data\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferHasChunkData </B> returns whether or not a buffer's payload\n has data that may be interpreted as chunk data."]
    pub fn acBufferHasChunkData(hBuffer: acBuffer, pHasChunkData: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferHasImageData(acBuffer hBuffer, bool8_t* pHasImageData)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pHasImageData\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload has image data\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferHasChunkData </B> returns whether or not a buffer's payload\n has data that may be interpreted as chunk data."]
    pub fn acBufferHasImageData(hBuffer: acBuffer, pHasImageData: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferIsCompressedImage(acBuffer hBuffer, bool8_t* pIsCompressedImage)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pIsCompressedImage\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload has compressed data\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferIsCompressedImage </B> returns whether or not a buffer's payload\n has data that may be interpreted as a compressed image."]
    pub fn acBufferIsCompressedImage(hBuffer: acBuffer, pHasImageData: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferIsIncomplete(acBuffer hBuffer, bool8_t* pIsIncomplete)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pIsIncomplete\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the data is incomplete\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferIsIncomplete </B> returns whether or not the payload is complete."]
    pub fn acBufferIsIncomplete(hBuffer: acBuffer, pIsIncomplete: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferDataLargerThanBuffer(acBuffer hBuffer, bool8_t* pDataLargerThanBuffer)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pDataLargerThanBuffer\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload is larger than the buffer\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferDataLargerThanBuffer </B> returns whether or not a buffer's\n payload data is larger than the buffer."]
    pub fn acBufferDataLargerThanBuffer(
        hBuffer: acBuffer,
        pDataLargerThanBuffer: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferVerifyCRC(acBuffer hBuffer, bool8_t* pVerifyCRC)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pVerifyCRC\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the calculated CRC value equals the one sent from the device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferVerifyCRC </B> calculates the CRC of a buffer's data and verifies\n it against the CRC value sent from the device via chunk data. This helps\n verify that no data was changed or missed during a transmission. This\n function calls a global helper function to calculate the CRC\n (acCalculateCRC32).\n\n @see\n  - acCalculateCRC"]
    pub fn acBufferVerifyCRC(hBuffer: acBuffer, pVerifyCRC: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetWidth(acBuffer hBuffer, size_t* pWidth)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pWidth\n  - Type: size_t*\n  - [Out] parameter\n  - Width of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetWidth </B> gets the width of the image in pixels. Images are\n self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acImageGetWidth(hBuffer: acBuffer, pWidth: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetHeight(acBuffer hBuffer, size_t* pHeight)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pHeight\n  - Type: size_t*\n  - [Out] parameter\n  - Height of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetHeight </B> gets the height of the image. Images are\n self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acImageGetHeight(hBuffer: acBuffer, pHeight: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetOffsetX(acBuffer hBuffer, size_t* pOffsetX)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pOffsetX\n  - Type: size_t*\n  - [Out] parameter\n  - Offset X of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetOffsetX </B> gets the offset of the image along the X-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetOffsetX(hBuffer: acBuffer, pOffsetX: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetOffsetY(acBuffer hBuffer, size_t* pOffsetY)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pOffsetY\n  - Type: size_t*\n  - [Out] parameter\n  - Offset Y of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetOffsetY </B> gets the offset of the image along the Y-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetOffsetY(hBuffer: acBuffer, pOffsetY: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPaddingX(acBuffer hBuffer, size_t* pPaddingX)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pPaddingX\n  - Type: size_t*\n  - [Out] parameter\n  - Padding X of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPaddingX </B> gets the padding of the image along the X-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetPaddingX(hBuffer: acBuffer, pPaddingX: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPaddingY(acBuffer hBuffer, size_t* pPaddingY)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pPaddingY\n  - Type: size_t*\n  - [Out] parameter\n  - Padding Y of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPaddingY </B> gets the padding of the image along the Y-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetPaddingY(hBuffer: acBuffer, pPaddingY: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPixelFormat(acBuffer hBuffer, uint64_t* pPixelFormat)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pPixelFormat\n  - Type: uint64_t*\n  - [Out] parameter\n  - Pixel format of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPixelFormat </B> gets the pixel format (PfncFormat) of the\n image, as defined by the PFNC (Pixel Format Naming Convention). Images are\n self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acImageGetPixelFormat(hBuffer: acBuffer, pPixelFormat: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetBitsPerPixel(acBuffer hBuffer, size_t* pBitsPerPixel)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pBitsPerPixel\n  - Type: size_t*\n  - [Out] parameter\n  - Bits per pixel of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetBitsPerPixel </B> gets the number of bits per pixel of the image\n from the integer value of the pixel format (PfncFormat). Internally, a public\n helper function is called (acGetBitsPerPixel).\n\n @see\n  - acGetBitsPerPixel"]
    pub fn acImageGetBitsPerPixel(hBuffer: acBuffer, pBitsPerPixel: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPixelEndianness(acBuffer hBuffer, AC_PIXEL_ENDIANNESS* pPixelEndianness)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pPixelEndianness\n  - Type: AC_PIXEL_ENDIANNESS*\n  - [Out] parameter\n  - Endianness of the pixels of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPixelEndianness </B> gets the pixel endianness\n (AC_PIXEL_ENDIANNESS) of the image. Images are self-describing, so the\n device does not need to be queried to get this information."]
    pub fn acImageGetPixelEndianness(
        hBuffer: acBuffer,
        pPixelEndianness: *mut AC_PIXEL_ENDIANNESS,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetTimestamp(acBuffer hBuffer, uint64_t* pTimestamp)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pTimestamp\n  - Type: uint64_t*\n  - Unit: nanoseconds\n  - [Out] parameter\n  - Timestamp of the image in nanoseconds\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetTimestamp </B> gets the timestamp of the image in nanoseconds.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetTimestamp(hBuffer: acBuffer, pTimestamp: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetTimestampNs(acBuffer hBuffer, uint64_t* pTimestampNs)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pTimestampNs\n  - Type: uint64_t*\n  - Unit: nanoseconds\n  - [Out] parameter\n  - Timestamp of the image in nanoseconds\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetTimestampNs </B> gets the timestamp of the image in nanoseconds.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetTimestampNs(hBuffer: acBuffer, pTimestampNs: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetData(acBuffer hBuffer, uint8_t** ppData)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param ppData\n  - Type: uint8_t**\n  - [Out] parameter\n  - Pointer to the payload data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetData </B> returns a pointer to the beginning of the image's\n payload data. The payload may include chunk data."]
    pub fn acImageGetData(hBuffer: acBuffer, ppData: *mut *mut u8) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acChunkDataGetChunk(acBuffer hBuffer, const char* pName, acNode* phChunk)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - Chunk data\n\n @param pName\n  - Type: const char*\n  - [In] parameter\n  - Name of the chunk\n  - Prefixed with 'Chunk'\n\n @param phChunk\n  - Type: acNode*\n  - [Out] parameter\n  - Requested node\n  - Null on failure\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acChunkDataGetChunk </B> gets a specified chunk, which can be used to\n retrieve the chunk value and related information available in its node type\n (maximum, minimum, node display name, etc)."]
    pub fn acChunkDataGetChunk(
        hBuffer: acBuffer,
        pName: *const ::std::os::raw::c_char,
        phChunk: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acChunkDataGetChunkAndAccessMode(acBuffer hBuffer, const char* pName, acNode* phChunkNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - Chunk data\n\n @param pName\n  - Type: const char*\n  - [In] parameter\n  - Name of the chunk\n  - Prefixed with 'Chunk'\n\n @param phChunkNode\n  - Type: acNode*\n  - [Out] parameter\n  - Requested node\n  - Null on failure\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Access mode of the requested node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acChunkDataGetChunkAndAccessMode </B> gets a specified chunk and its\n access mode, returning it as a node in order to preserve metadata related to\n the chunk."]
    pub fn acChunkDataGetChunkAndAccessMode(
        hBuffer: acBuffer,
        pName: *const ::std::os::raw::c_char,
        phChunkNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCompressedImageGetPixelFormat(acBuffer hBuffer, uint64_t* pPixelFormat)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pPixelFormat\n  - Type: uint64_t*\n  - [Out] parameter\n  - Pixel format of the compressed image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCompressedImageGetPixelFormat </B> gets the pixel format (PfncFormat) of the\n compressed image, as defined by the PFNC (Pixel Format Naming Convention). Compressed\n images are self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acCompressedImageGetPixelFormat(hBuffer: acBuffer, pPixelFormat: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCompressedImageGetTimestamp(acBuffer hBuffer, uint64_t* pTimestamp)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pTimestamp\n  - Type: uint64_t*\n  - Unit: nanoseconds\n  - [Out] parameter\n  - Timestamp of the compressed image in nanoseconds\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCompressedImageGetTimestamp </B> gets the timestamp of the compressed image in nanoseconds.\n Compressed images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acCompressedImageGetTimestamp(hBuffer: acBuffer, pTimestamp: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCompressedImageGetTimestampNs(acBuffer hBuffer, uint64_t* pTimestampNs)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param pTimestampNs\n  - Type: uint64_t*\n  - Unit: nanoseconds\n  - [Out] parameter\n  - Timestamp of the compressed image in nanoseconds\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCompressedImageGetTimestampNs </B> gets the timestamp of the compressed image in nanoseconds.\n Compressed images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acCompressedImageGetTimestampNs(hBuffer: acBuffer, pTimestampNs: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCompressedImageGetData(acBuffer hBuffer, uint8_t** ppData)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - An image\n\n @param ppData\n  - Type: uint8_t**\n  - [Out] parameter\n  - Pointer to the payload data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCompressedImageGetData </B> returns a pointer to the beginning of the compressed image's\n payload data. The payload may include chunk data."]
    pub fn acCompressedImageGetData(hBuffer: acBuffer, ppData: *mut *mut u8) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryCreate(uint8_t* pData, size_t dataSize, size_t width, size_t height, uint64_t pixelFormat, acBuffer* phDst)\n\n FactoryCreate(uint8_t pData, size_t dataSize, size_t width, size_t height,\n uint64_t pixelFormat, acBuffer* phDst)\n\n @param pData\n  - Type: uint8_t*\n  - [Out] parameter\n  - Pointer to the beginning of the payload data\n\n @param dataSize\n  - Type: size_t\n  - [In] parameter\n  - Size of the data\n\n @param width\n  - Type: size_t\n  - [In] parameter\n  - Width of the image to create\n\n @param height\n  - Type: size_t\n  - [In] parameter\n  - Height of the image to create\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format of the image to create\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Image created from the parameters\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryCreate </B> creates an image (acBuffer) from a minimal set\n of parameters. Images created with the image factory must be destroyed\n (acImageFactoryDestroy) when no longer needed.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryCreate(
        pData: *mut u8,
        dataSize: usize,
        width: usize,
        height: usize,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    pub fn acImageFactoryCreateEmpty(
        dataSize: usize,
        width: usize,
        height: usize,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryShallow(uint8_t* pData, size_t dataSize, size_t width, size_t height, uint64_t pixelFormat, acBuffer* phDst);\n\n @param pData\n  - Type: uint8_t*\n  - [Out] parameter\n  - Pointer to the beginning of the payload data\n\n @param dataSize\n  - Type: size_t\n  - [In] parameter\n  - Size of the data\n\n @param width\n  - Type: size_t\n  - [In] parameter\n  - Width of the image to create\n\n @param height\n  - Type: size_t\n  - [In] parameter\n  - Height of the image to create\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format of the image to create\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Image created from the parameters\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryShallow(
        pData: *mut u8,
        dataSize: usize,
        width: usize,
        height: usize,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryCreateCompressedImage(uint8_t* pData, size_t dataSize, uint64_t pixelFormat, acBuffer* phDst)\n\n @param pData\n  - Type: uint8_t*\n  - [Out] parameter\n  - Pointer to the beginning of the payload data\n\n @param dataSize\n  - Type: size_t\n  - [In] parameter\n  - Size of the data\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format of the compressed image to create\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Compressed image created from the parameters\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryCreateCompressedImage </B> creates a compressed image\n (acBuffer) from a minimal set of parameters. Images created with the image\n factory must be destroyed (acImageFactoryDestroy) when no longer needed.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryCreateCompressedImage(
        pData: *mut u8,
        dataSize: usize,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryCopy(acBuffer hSrc, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to copy\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Deep copy of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryCopy </B> creates a deep copy of an image (acBuffer) from\n another image. Images created with the image factory must be destroyed\n (acImageFactoryDestroy) when no longer needed.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryCopy(hSrc: acBuffer, phDst: *mut acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    pub fn acImageFactoryCopyCompressedImage(hSrc: acBuffer, phDst: *mut acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryConvert(acBuffer hSrc, uint64_t pixelFormat, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to convert\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format to convert to\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Convert image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryConvert </B> converts an image (acBuffer) to the selected pixel\n format. In doing so, it creates a completely new image, similar to a deep copy\n but with a different pixel format. Images created with the image factory must\n be destroyed (acImageFactoryDestroy) when no longer needed; otherwise, memory\n will leak.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryConvert(
        hSrc: acBuffer,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryDecompressImage(acBuffer hSrc, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to convert\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Decompressed image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryDecompressImage </B> decompresses a compressed image (acBuffer).\n In doing so, it creates a completely new image, similar to a deep copy\n but with an uncompressed pixel format. Images created with the image factory must\n be destroyed (acImageFactoryDestroy) when no longer needed; otherwise, memory\n will leak.\n\n @see\n  - acBuffer"]
    pub fn acImageFactoryDecompressImage(hSrc: acBuffer, phDst: *mut acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryConvertBayerAlgorithm(acBuffer hSrc, uint64_t pixelFormat, AC_BAYER_ALGORITHM bayerAlgo, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to convert\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format to convert to\n\n @param bayerAlgo\n  - Type: AC_BAYER_ALGORITHM\n  - [In] parameter\n  - Bayer conversion algorithm to use\n  - Only applicable when converting from bayer\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Converted image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryConvert </B> converts an image (acBuffer) to the selected pixel\n format. In doing so, it creates a completely new image, similar to a deep copy\n but with a different pixel format. Images created with the image factory must\n be destroyed (acImageFactoryDestroy) when no longer needed; otherwise, memory\n will leak.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryConvertBayerAlgorithm(
        hSrc: acBuffer,
        pixelFormat: u64,
        bayerAlgo: AC_BAYER_ALGORITHM,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryDestroy(acBuffer hBuffer)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - Image to destroy\n  - Image must be from image factory\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryDestroy </B> cleans up an image (acBuffer) and deallocates\n its memory. It must be called on any image created by the image factory\n (acImageFactoryCreate, acImageFactoryCopy, acImageFactoryConvert, acImageFactoryDecompressImage).\n\n @see\n  - acBuffer\n  - acImageFactoryCreate"]
    pub fn acImageFactoryDestroy(hBuffer: acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    pub fn acImageFactoryDestroyCompressedImage(hBuffer: acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactorySelectBits(acBuffer hSrc, size_t numBits, int offset, acBuffer* phDst);\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to select bits from\n\n @param numBits\n  - Type: size_t\n  - [In] parameter\n  - Number of Bits to select\n\n @param offset\n  - Type: int\n  - [In] parameter\n  - Offset the Bits to select\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Copy of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactorySelectBits </B> select bits from an image.\n\n @see\n  - acBuffer\n  - acImageFactoryCreate"]
    pub fn acImageFactorySelectBits(
        hSrc: acBuffer,
        numBits: usize,
        offset: ::std::os::raw::c_int,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactorySelectBitsAndScale(acBuffer hSrc, size_t numBits, double offset, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to select bits and scale\n\n @param numBits\n  - Type: size_t\n  - [In] parameter\n  - Number of Bits to scale to\n\n @param offset\n  - Type: double\n  - [In] parameter\n  - Offset to scale to\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Scaled copy of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactorySelectBitsAndScale </B> scales image.\n\n @see\n  - acBuffer\n  - acImageFactoryCreate"]
    pub fn acImageFactorySelectBitsAndScale(
        hSrc: acBuffer,
        numBits: usize,
        offset: f64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryProcessSoftwareLUT(acBuffer hSrc, uint8_t* pLUT, size_t len, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to select bits and scale\n\n @param pLUT\n  - Type: uint8_t*\n  - [In] parameter\n  - Pointer to the beginning of the lookup table\n\n @param len\n  - Type: size_t\n  - [In] parameter\n  - Length of image buffer\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Copy of the image with redefined of values\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryProcessSoftwareLUT </B> runs an image through a lookup table, allowing for a redefinition of values.\n\n @see\n  - acBuffer"]
    pub fn acImageFactoryProcessSoftwareLUT(
        hSrc: acBuffer,
        pLUT: *mut u8,
        len: usize,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryDeinterleaveChannels(acBuffer hSrc, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to deinterleave channels\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Copy of the planar image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryDeinterleaveChannels </B> separates interleaved channels into a planar image.\n\n @see\n  - acBuffer"]
    pub fn acImageFactoryDeinterleaveChannels(hSrc: acBuffer, phDst: *mut acBuffer) -> AC_ERROR;
}
unsafe extern "C" {
    pub fn acImageFactoryDeinterleaveChannelsShallow(
        hSrc: acBuffer,
        pData: *mut u8,
        len: usize,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    pub fn acImageFactoryDeinterleaveChannelsLen(hSrc: acBuffer, len: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactorySplitChannels(acBuffer hSrc, acBuffer* phDst[], size_t* numBuffers)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to split channels from\n\n @param phDst[]\n  - Type: acBuffer*\n  - [Out] parameter\n  - Pointer to a vector with splited image\n\n @param numBuffers\n  - Type: size_t*\n  - [In] parameter\n  - Number of buffers to split image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactorySplitChannels </B> takes an interleaved image and separates the channels into multiple images.\n\n @see\n  - acBuffer"]
    pub fn acImageFactorySplitChannels(
        hSrc: acBuffer,
        phDst: *mut *mut acBuffer,
        numBuffers: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamCreate(acNodeMap hNodeMap, acFeatureStream* phFeatureStream)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - Node map to stream\n\n @param phFeatureStream\n  - Type: acFeatureStream*\n  - [Out] parameter\n  - Feature stream object to create\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStream </B> builds a feature stream from a device's node map\n (acNodeMap). This node map cannot be changed later; another feature stream\n must be created to stream another node map.\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamCreate(
        hNodeMap: acNodeMap,
        phFeatureStream: *mut acFeatureStream,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamDestroy(acFeatureStream hFeatureStream)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - Feature stream object to destroy\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamDestroy </B> destroys a feature stream object, cleaning up\n allocated memory."]
    pub fn acFeatureStreamDestroy(hFeatureStream: acFeatureStream) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamWrite(acFeatureStream hFeatureStream)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamWrite </B> streams all selected features from the node map\n (acNodeMap) to a file.\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamWrite(hFeatureStream: acFeatureStream) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamWriteFileName(acFeatureStream hFeatureStream, const char* pFileName)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @param pFileName\n  - Type: const char*\n  - [In] parameter\n  - Name of the file to stream to\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamWriteFileName </B> streams all selected features from the\n node map (acNodeMap) to a file.\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamWriteFileName(
        hFeatureStream: acFeatureStream,
        pFileName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamRead(acFeatureStream hFeatureStream)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamRead </B> streams all selected features from a file to the\n node map (acNodeMap).\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamRead(hFeatureStream: acFeatureStream) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamReadFileName(acFeatureStream hFeatureStream, const char* pFileName)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @param pFileName\n  - Type: const char*\n  - [In] parameter\n  - Name of the file to stream from\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamReadFileName </B> streams all selected features from a file\n to the node map (acNodeMap).\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamReadFileName(
        hFeatureStream: acFeatureStream,
        pFileName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamSelect(acFeatureStream hFeatureStream, const char* pFeatureName)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @param pFeatureName\n  - Type: const char*\n  - [In] parameter\n  - Name of the feature to select\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamSelect </B> adds a single streamable feature to the list of\n selected features to stream. If called for the first time, <B>\n acFeatureStreamSelect </B> also sets an internal 'select-all' flag to false."]
    pub fn acFeatureStreamSelect(
        hFeatureStream: acFeatureStream,
        pFeatureName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNode(acNodeMap hNodeMap, const char* pNodeName, acNode* phNode)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node to retrieve\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves a node."]
    pub fn acNodeMapGetNode(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        phNode: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNodeAndAccessMode(acNodeMap hNodeMap, const char* pNodeName, acNode* phNode, AC_ACCESS_MODE* pNodeAccess)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node to retrieve\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @param pNodeAccess\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - The node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNodeAndAccessMode </B> retrieves a node with its access mode."]
    pub fn acNodeMapGetNodeAndAccessMode(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        phNode: *mut acNode,
        pNodeAccess: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapInvalidateNodes(acNodeMap hNodeMap)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapInvalidateNodes </B> invalidates all of its nodes."]
    pub fn acNodeMapInvalidateNodes(hNodeMap: acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetDeviceName(acNodeMap hNodeMap, char* pDeviceNameBuf, size_t* pBufLen)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pDeviceNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Name of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetDeviceName </B> retrieves the node map's device name."]
    pub fn acNodeMapGetDeviceName(
        hNodeMap: acNodeMap,
        pDeviceNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapPoll(acNodeMap hNodeMap, int64_t elapsedTime)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param elapsedTime\n  - Type: int64_t\n  - Unit: milliseconds\n  - [In] parameter\n  - Time since the last poll\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapPoll </B> polls the node map."]
    pub fn acNodeMapPoll(hNodeMap: acNodeMap, elapsedTime: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapLock(acNodeMap hNodeMap)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> locks the node map."]
    pub fn acNodeMapLock(hNodeMap: acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapUnlock(acNodeMap hNodeMap)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> unlocks the node map."]
    pub fn acNodeMapUnlock(hNodeMap: acNodeMap) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapTryLock(acNodeMap hNodeMap, bool8_t* pLocked)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pLocked\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the lock succeeded\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> tries to lock the node map, returning whether or not\n the call succeeded."]
    pub fn acNodeMapTryLock(hNodeMap: acNodeMap, pLocked: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNumNodes(acNodeMap hNodeMap, uint64_t* pNumNodes)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNumNodes\n  - Type: uint64_t*\n  - [Out] parameter\n  - Total number of nodes in the node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves the number of nodes in the node map."]
    pub fn acNodeMapGetNumNodes(hNodeMap: acNodeMap, pNumNodes: *mut u64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNodeByIndex(acNodeMap hNodeMap, size_t index, acNode* phNode)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the node\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves a node by its index."]
    pub fn acNodeMapGetNodeByIndex(
        hNodeMap: acNodeMap,
        index: usize,
        phNode: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNodeByIndexAndAccessMode(acNodeMap hNodeMap, size_t index, acNode* phNode, AC_ACCESS_MODE* pNodeAccess)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the node\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @param pNodeAccess\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - The node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves a node by its index along with its access\n mode."]
    pub fn acNodeMapGetNodeByIndexAndAccessMode(
        hNodeMap: acNodeMap,
        index: usize,
        phNode: *mut acNode,
        pNodeAccess: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetStringValue(acNodeMap hNodeMap, const char* pNodeName, char* pValueBuf, size_t* pBufLen)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValueBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Value of the node\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetStringValue </B> acts as a shortcut for retrieving the value\n of a string node."]
    pub fn acNodeMapGetStringValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValueBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetIntegerValue(acNodeMap hNodeMap, const char* pNodeName, int64_t* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: int64_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetIntegerValue </B> acts as a shortcut for retrieving the value\n of an integer node."]
    pub fn acNodeMapGetIntegerValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *mut i64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetFloatValue(acNodeMap hNodeMap, const char* pNodeName, double* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: double*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetFloatValue </B> acts as a shortcut for retrieving the value of\n a float node."]
    pub fn acNodeMapGetFloatValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *mut f64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetBooleanValue(acNodeMap hNodeMap, const char* pNodeName, bool8_t* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: bool8_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetBooleanValue </B> acts as a shortcut for retrieving the value\n of a boolean node."]
    pub fn acNodeMapGetBooleanValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *mut bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetEnumerationValue(acNodeMap hNodeMap, const char* pNodeName, char* pSymbolicBuf, size_t* pBufLen)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Symbolic of the current entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetEnumerationValue </B> acts as a shortcut for retrieving the\n entry of an enumeration node."]
    pub fn acNodeMapGetEnumerationValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetStringValue(acNodeMap hNodeMap, const char* pNodeName, const char* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: const char*\n  - [In] parameter\n  - String value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetStringValue </B> acts as a shortcut for setting the value of a\n string node."]
    pub fn acNodeMapSetStringValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetIntegerValue(acNodeMap hNodeMap, const char* pNodeName, int64_t value)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param value\n  - Type: int64_t\n  - [In] parameter\n  - Integer value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetIntegerValue </B> acts as a shortcut for setting the value of\n an integer node."]
    pub fn acNodeMapSetIntegerValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        value: i64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetFloatValue(acNodeMap hNodeMap, const char* pNodeName, double value)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param value\n  - Type: double\n  - [In] parameter\n  - Float value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetFloatValue </B> acts as a shortcut for setting the value of a\n float node."]
    pub fn acNodeMapSetFloatValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        value: f64,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetBooleanValue(acNodeMap hNodeMap, const char* pNodeName, bool8_t value)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param value\n  - Type: bool8_t\n  - [In] parameter\n  - Boolean value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetBooleanValue </B> acts as a shortcut for setting the value of\n a boolean node."]
    pub fn acNodeMapSetBooleanValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        value: bool8_t,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetEnumerationValue(acNodeMap hNodeMap, const char* pNodeName, const char* pSymbolic)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pSymbolic\n  - Type: const char*\n  - [In] parameter\n  - Name of the entry node to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetEnumerationValue </B> acts as a shortcut for setting the value\n of an enumeration node."]
    pub fn acNodeMapSetEnumerationValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pSymbolic: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapExecute(acNodeMap hNodeMap, const char* pNodeName)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapExecute </B> acts as a shortcut for executing a command node."]
    pub fn acNodeMapExecute(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCallbackRegister(acCallback* phCallback, acNode hNode, acCallbackFunction callbackFunction, void* pUserData)\n\n @param phCallback\n  - Type: acCallback*\n  - [Out] parameter\n  - The callback handle\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node to set the callback on\n\n @param callbackFunction\n  - Type: acCallbackFunction\n  - [In] parameter\n  - The function to call\n\n @param pUserData\n  - Type: void*\n  - [Out] parameter\n  - Accepts null\n  - User data available within the callback function\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCallbackRegister </B> registers a callback on a node. The callback\n handle (acCallback) should be stored in order to deregister the callback\n later.\n\n @see\n  - acCallback"]
    pub fn acCallbackRegister(
        phCallback: *mut acCallback,
        hNode: acNode,
        callbackFunction: acCallbackFunction,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCallbackDeregister(acCallback hCallback)\n\n @param hCallback\n  - Type: acCallback\n  - [In] parameter\n  - The callback handle\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCallbackDeregister </B> deregisters the callback."]
    pub fn acCallbackDeregister(hCallback: acCallback) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetAccessMode(acNode hNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetAccessMode </B> retrieves a node's access mode."]
    pub fn acNodeGetAccessMode(hNode: acNode, pAccessMode: *mut AC_ACCESS_MODE) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetAlias(acNode hNode, acNode* phAliasNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param phAliasNode\n  - Type: acNode*\n  - [Out] parameter\n  - Alias node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetAlias </B> retrieves a node's alias node."]
    pub fn acNodeGetAlias(hNode: acNode, phAliasNode: *mut acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetCachingMode(acNode hNode, AC_CACHING_MODE* pCachingMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pCachingMode\n  - Type: AC_CACHING_MODE*\n  - [Out] parameter\n  - Caching mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetCachingMode </B> retrieves a node's caching mode."]
    pub fn acNodeGetCachingMode(hNode: acNode, pCachingMode: *mut AC_CACHING_MODE) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetCastAlias(acNode hNode, acNode* phAliasNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param phAliasNode\n  - Type: acNode*\n  - [Out] parameter\n  - Cast alias\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetCastAlias </B> retrieves a node's cast alias."]
    pub fn acNodeGetCastAlias(hNode: acNode, phAliasNode: *mut acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNumChildren(acNode hNode, size_t* pNumChildren)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNumChildren\n  - Type: size_t*\n  - [Out] parameter\n  - Number of child nodes\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNumChildren </B> retrieves the number of a node's children."]
    pub fn acNodeGetNumChildren(hNode: acNode, pNumChildren: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetChild(acNode hNode, size_t index, acNode* phChildNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the child\n\n @param phChildNode\n  - Type: acNode*\n  - [Out] parameter\n  - Child node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetChild </B> retrieves a node's child node."]
    pub fn acNodeGetChild(hNode: acNode, index: usize, phChildNode: *mut acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetChildAndAccessMode(acNode hNode, size_t index, acNode* phChildNode, AC_ACCESS_MODE* accessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the child\n\n @param phChildNode\n  - Type: acNode*\n  - [Out] parameter\n  - Child node\n\n @param accessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Child node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetChildAndAccessMode </B> retrieves a node's child node and the\n child's access mode."]
    pub fn acNodeGetChildAndAccessMode(
        hNode: acNode,
        index: usize,
        phChildNode: *mut acNode,
        accessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDescription(acNode hNode, char* pDescription, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDescription\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Description of the node\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDescription </B> retrieves a node's longer description."]
    pub fn acNodeGetDescription(
        hNode: acNode,
        pDescription: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDeviceName(acNode hNode, char* pDeviceName, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDeviceName\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Device name of the node\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDeviceName </B> retrieves a node's device name."]
    pub fn acNodeGetDeviceName(
        hNode: acNode,
        pDeviceName: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDisplayName(acNode hNode, char* pDisplayName, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDisplayName\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Display name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDisplayName </B> retrieves a node's display name."]
    pub fn acNodeGetDisplayName(
        hNode: acNode,
        pDisplayName: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDocuURL(acNode hNode, char* pDocuURL, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDocuURL\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Document URL\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDocuURL </B> retrieves a node's document URL."]
    pub fn acNodeGetDocuURL(
        hNode: acNode,
        pDocuURL: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetEventID(acNode hNode, char* pEventIDBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pEventIDBuf\n  - Type: char*\n  - [Out] parameter\n  - Event ID\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetEventID </B> retrieves a node's event ID."]
    pub fn acNodeGetEventID(
        hNode: acNode,
        pEventIDBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetName(acNode hNode, char* pNameBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetName </B> retrieves a node's name."]
    pub fn acNodeGetName(
        hNode: acNode,
        pNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetFullyQualifiedName(acNode hNode, char* pNameBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Name\n\n @param pBufLen\n  - Type: size_t*\n  - In/out parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetFullyQualifiedName </B> retrieves a node's fully qualified name."]
    pub fn acNodeGetFullyQualifiedName(
        hNode: acNode,
        pNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNamespace(acNode hNode, AC_NAMESPACE* pNameSpace)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNameSpace\n  - Type: AC_NAMESPACE*\n  - [Out] parameter\n  - Namespace\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNamespace </B> retrieves a node's namespace."]
    pub fn acNodeGetNamespace(hNode: acNode, pNameSpace: *mut AC_NAMESPACE) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNumParents(acNode hNode, size_t* pNumParents)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNumParents\n  - Type: size_t*\n  - [Out] parameter\n  - Number of parent nodes\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNumParents </B> retrieves the number of a node's parents."]
    pub fn acNodeGetNumParents(hNode: acNode, pNumParents: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetParent(acNode hNode, size_t index, acNode* phParentNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the parent\n\n @param phParentNode\n  - Type: acNode*\n  - [Out] parameter\n  - The parent node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetParent </B> retrieves a node's parent node."]
    pub fn acNodeGetParent(hNode: acNode, index: usize, phParentNode: *mut acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetParentAndAccessMode(acNode hNode, size_t index, acNode* phParentNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the parent node\n\n @param phParentNode\n  - Type: acNode*\n  - [Out] parameter\n  - The parent node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Parent node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetParentAndAccessMode </B> retrieves a node's parent node and the\n parent's access mode."]
    pub fn acNodeGetParentAndAccessMode(
        hNode: acNode,
        index: usize,
        phParentNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetPollingTime(acNode hNode, int64_t* pPollingTime)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pPollingTime\n  - Type: int64_t*\n  - [Out] parameter\n  - Polling time\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetPollingTime </B> retrieves a node's polling time in milliseconds."]
    pub fn acNodeGetPollingTime(hNode: acNode, pPollingTime: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetPrincipalInterfaceType(acNode hNode, AC_INTERFACE_TYPE* pInterfaceType)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pInterfaceType\n  - Type: AC_INTERFACE_TYPE*\n  - [Out] parameter\n  - Node type\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetPrincipalInterfaceType </B> retrieves a node's type."]
    pub fn acNodeGetPrincipalInterfaceType(
        hNode: acNode,
        pInterfaceType: *mut AC_INTERFACE_TYPE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetProperty(acNode hNode, const char* pPropertyName, char* pPropertyValueBuf, size_t* pPropertyValueBufLen, char* pPropertyAttributeBuf, size_t* pPropertyAttributeBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pPropertyName\n  - Type: const char*\n  - [In] parameter\n  - Accepts null\n  - List of property names\n\n @param pPropertyValueBuf\n  - Type: char*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @param pPropertyValueBufLen\n  - Type: size_t*\n  - [Out] parameter\n  - Accepts null\n  - List of property values\n\n @param pPropertyAttributeBuf\n  - Type: char*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @param pPropertyAttributeBufLen\n  - Type: size_t*\n  - [Out] parameter\n  - The node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetProperty </B> retrieves a node's properties and their values."]
    pub fn acNodeGetProperty(
        hNode: acNode,
        pPropertyName: *const ::std::os::raw::c_char,
        pPropertyValueBuf: *mut ::std::os::raw::c_char,
        pPropertyValueBufLen: *mut usize,
        pPropertyAttributeBuf: *mut ::std::os::raw::c_char,
        pPropertyAttributeBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNumPropertyNames(acNode hNode, size_t* pNumPropertyNames)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNumPropertyNames\n  - Type: size_t*\n  - [Out] parameter\n  - Number of node properties\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNumPropertyNames </B> retrieves the number of a node's property\n names."]
    pub fn acNodeGetNumPropertyNames(hNode: acNode, pNumPropertyNames: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetPropertyName(acNode hNode, size_t index, char* pPropertyNameBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the property\n\n @param pPropertyNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Property name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetPropertyName </B> retrieves a node's property name."]
    pub fn acNodeGetPropertyName(
        hNode: acNode,
        index: usize,
        pPropertyNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetToolTip(acNode hNode, char* pToolTipBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pToolTipBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Tool tip\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetToolTip </B> retrieves a node's shorter description."]
    pub fn acNodeGetToolTip(
        hNode: acNode,
        pToolTipBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeInvalidateNode(acNode hNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeInvalidateNode </B> invalidates a node."]
    pub fn acNodeInvalidateNode(hNode: acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetVisibility(acNode hNode, AC_VISIBILITY* pVisibility)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pVisibility\n  - Type: AC_VISIBILITY*\n  - [Out] parameter\n  - Visibility\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetVisibility </B> retrieves a node's suggested visibility."]
    pub fn acNodeGetVisibility(hNode: acNode, pVisibility: *mut AC_VISIBILITY) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeImposeAccessMode(acNode hNode, AC_ACCESS_MODE imposedAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param imposedAccessMode\n  - Type: AC_ACCESS_MODE\n  - [In] parameter\n  - Imposed access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeImposeAccessMode </B> imposes an access mode on a node."]
    pub fn acNodeImposeAccessMode(hNode: acNode, imposedAccessMode: AC_ACCESS_MODE) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeImposeVisibility(acNode hNode, AC_VISIBILITY imposedVisibility)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param imposedVisibility\n  - Type: AC_VISIBILITY\n  - [In] parameter\n  - Imposed visibility\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeImposeVisibility </B> imposes a visibility setting on a node."]
    pub fn acNodeImposeVisibility(hNode: acNode, imposedVisibility: AC_VISIBILITY) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsCachable(acNode hNode, bool8_t* pIsCachable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsCachable\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node value is cachable\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsCachable </B> retrieves whether or not a node is cachable."]
    pub fn acNodeIsCachable(hNode: acNode, pIsCachable: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsDeprecated(acNode hNode, bool8_t* pIsDeprecated)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsDeprecated\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is deprecated\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsDeprecated </B> retrieves whether or not a node is deprecated."]
    pub fn acNodeIsDeprecated(hNode: acNode, pIsDeprecated: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsFeature(acNode hNode, bool8_t* pIsFeature)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsFeature\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is a feature\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsFeature </B> retrieves whether or not a node is a feature."]
    pub fn acNodeIsFeature(hNode: acNode, pIsFeature: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsStreamable(acNode hNode, bool8_t* pIsStreamable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsStreamable\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is streamable\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsStreamable </B> retrieves whether or not a node is streamable."]
    pub fn acNodeIsStreamable(hNode: acNode, pIsStreamable: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acValueToString(acNode hNode, char* pValueBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts any node type\n\n @param pValueBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Value as a string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acValueToString </B> gets a node's value as a string."]
    pub fn acValueToString(
        hNode: acNode,
        pValueBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acValueFromString(acNode hNode, const char* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts any node type\n\n @param pValue\n  - Type: const char*\n  - [In] parameter\n  - Value as a string\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acValueFromString </B> sets a node's value from a string."]
    pub fn acValueFromString(hNode: acNode, pValue: *const ::std::os::raw::c_char) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acValueIsValueCacheValid(acNode hNode, bool8_t* pIsValid)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts any node type\n\n @param pIsValid\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if cache value is valid\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acValueIsValueCacheValid </B> retrieves whether or not a node's value\n cache is valid."]
    pub fn acValueIsValueCacheValid(hNode: acNode, pIsValid: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetInc(acNode hNode, int64_t* pIncrement)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pIncrement\n  - Type: int64_t*\n  - [Out] parameter\n  - Value increment\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetInc </B> retrieves the increment between valid values."]
    pub fn acIntegerGetInc(hNode: acNode, pIncrement: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetIncMode(acNode hNode, AC_INC_MODE* pIncrementMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pIncrementMode\n  - Type: AC_INC_MODE*\n  - [Out] parameter\n  - Increment mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetIncMode </B> retrieves the increment mode."]
    pub fn acIntegerGetIncMode(hNode: acNode, pIncrementMode: *mut AC_INC_MODE) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetMax(acNode hNode, int64_t* pMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pMaximum\n  - Type: int64_t*\n  - [Out] parameter\n  - Maximum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetMax </B> retrieves the maximum value."]
    pub fn acIntegerGetMax(hNode: acNode, pMaximum: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetMin(acNode hNode, int64_t* pMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pMinimum\n  - Type: int64_t*\n  - [Out] parameter\n  - Minimum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetMin </B> retrieves the minimum value."]
    pub fn acIntegerGetMin(hNode: acNode, pMinimum: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetRepresentation(acNode hNode, AC_REPRESENTATION* pRepresentation)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pRepresentation\n  - Type: AC_REPRESENTATION*\n  - [Out] parameter\n  - Numeric representation\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetRepresentation </B> retrieves the value representation."]
    pub fn acIntegerGetRepresentation(
        hNode: acNode,
        pRepresentation: *mut AC_REPRESENTATION,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetUnit(acNode hNode, char* pUnitBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pUnitBuf\n  - Type: char*\n  - [Out] parameter\n  - Unit of the value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetValue </B> represents the units of the value."]
    pub fn acIntegerGetUnit(
        hNode: acNode,
        pUnitBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetValue(acNode hNode, int64_t* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pValue\n  - Type: int64_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetValue </B> retrieves the current value."]
    pub fn acIntegerGetValue(hNode: acNode, pValue: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerImposeMin(acNode hNode, int64_t imposedMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param imposedMinimum\n  - Type: int64_t\n  - [In] parameter\n  - Minimum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerImposeMin </B> imposes a minimum. New minimum must be greater\n than the actual minimum."]
    pub fn acIntegerImposeMin(hNode: acNode, imposedMinimum: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerImposeMax(acNode hNode, int64_t imposedMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param imposedMaximum\n  - Type: int64_t\n  - [In] parameter\n  - Maximum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerImposeMax </B> imposes a maximum. New maximum must be less than\n the actual maximum."]
    pub fn acIntegerImposeMax(hNode: acNode, imposedMaximum: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerSetValue(acNode hNode, int64_t value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param value\n  - Type: int64_t\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerSetValue </B> sets a new value."]
    pub fn acIntegerSetValue(hNode: acNode, value: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBooleanGetValue(acNode hNode, bool8_t* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts boolean nodes\n\n @param pValue\n  - Type: bool8_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBooleanGetValue </B> retrieves a boolean node's value."]
    pub fn acBooleanGetValue(hNode: acNode, pValue: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBooleanSetValue(acNode hNode, bool8_t value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts boolean nodes\n\n @param value\n  - Type: bool8_t\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBooleanSetValue </B> sets a boolean node's value."]
    pub fn acBooleanSetValue(hNode: acNode, value: bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCommandExecute(acNode hNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts command nodes\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCommandExecute </B> executes an action associated with the command node."]
    pub fn acCommandExecute(hNode: acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCommandIsDone(acNode hNode, bool8_t* pIsDone)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts command nodes\n\n @param pIsDone\n  - Type: bool8_t*\n  - [Out] parameter\n  - False if the action is currently being processed\n  - Otherwise, true\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCommandIsDone </B> retrieves whether or not the execution of the node\n has completed."]
    pub fn acCommandIsDone(hNode: acNode, pIsDone: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatSetValue(acNode hNode, double value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param value\n  - Type: double\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatSetValue </B> sets a new value."]
    pub fn acFloatSetValue(hNode: acNode, value: f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetValue(acNode hNode, double* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pValue\n  - Type: double*\n  - [Out] parameter\n  - Current value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetValue </B> retrieves the current value."]
    pub fn acFloatGetValue(hNode: acNode, pValue: *mut f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetMin(acNode hNode, double* pMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pMinimum\n  - Type: double*\n  - [Out] parameter\n  - Minimum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetMin </B> retrieves the minimum value."]
    pub fn acFloatGetMin(hNode: acNode, pMinimum: *mut f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetMax(acNode hNode, double* pMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pMaximum\n  - Type: double*\n  - [Out] parameter\n  - Maximum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetMax </B> retrieves the maximum value."]
    pub fn acFloatGetMax(hNode: acNode, pMaximum: *mut f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatHasInc(acNode hNode, bool8_t* pHasInc)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pHasInc\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the value has a software-imposed increment\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatHasInc </B> retrieves whether or not the value has an increment."]
    pub fn acFloatHasInc(hNode: acNode, pHasInc: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetIncMode(acNode hNode, AC_INC_MODE* pIncMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pIncMode\n  - Type: AC_INC_MODE*\n  - [Out] parameter\n  - Increment mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetIncMode </B> retrieves the increment (if there is one)."]
    pub fn acFloatGetIncMode(hNode: acNode, pIncMode: *mut AC_INC_MODE) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetInc(acNode hNode, double* pIncrement)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pIncrement\n  - Type: double*\n  - [Out] parameter\n  - Increment value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetInc </B> retrieves the value increment (if there is one). Get\n the increment after checking whether there is one (acFloatHasInc).\n\n @see\n  - acFloatHasInc"]
    pub fn acFloatGetInc(hNode: acNode, pIncrement: *mut f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetRepresentation(acNode hNode, AC_REPRESENTATION* pRepresentation)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pRepresentation\n  - Type: AC_REPRESENTATION*\n  - [Out] parameter\n  - Numeric representation\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetRepresentation </B> retrieves the value representation."]
    pub fn acFloatGetRepresentation(
        hNode: acNode,
        pRepresentation: *mut AC_REPRESENTATION,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetUnit(acNode hNode, char* pUnitBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pUnitBuf\n  - Type: char*\n  - [Out] parameter\n  - Value unit\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetUnit </B> retrieves the units of the value."]
    pub fn acFloatGetUnit(
        hNode: acNode,
        pUnitBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetDisplayNotation(acNode hNode, AC_DISPLAY_NOTATION* pDisplayNotation)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pDisplayNotation\n  - Type: AC_DISPLAY_NOTATION*\n  - [Out] parameter\n  - Display notation\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetDisplayNotation </B> retrieves the best way to display the\n float, either by floating point, scientific notation, or both depending on the\n value (automatic)."]
    pub fn acFloatGetDisplayNotation(
        hNode: acNode,
        pDisplayNotation: *mut AC_DISPLAY_NOTATION,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetDisplayPrecision(acNode hNode, int64_t* pDisplayPrecision)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pDisplayPrecision\n  - Type: int64_t*\n  - [Out] parameter\n  - Floating point precision\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetDisplayPrecision </B> retrieves the floating point precision of\n the value."]
    pub fn acFloatGetDisplayPrecision(hNode: acNode, pDisplayPrecision: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatImposeMin(acNode hNode, double imposedMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param imposedMinimum\n  - Type: double\n  - [In] parameter\n  - Minimum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatImposeMin </B> imposes a minimum. New minimum must be greater than\n the actual minimum."]
    pub fn acFloatImposeMin(hNode: acNode, imposedMinimum: f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatImposeMax(acNode hNode, double imposedMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param imposedMaximum\n  - Type: double\n  - [In] parameter\n  - Maximum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatImposeMax </B> imposes a maximum. New maximum must be less than the\n actual maximum."]
    pub fn acFloatImposeMax(hNode: acNode, imposedMaximum: f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acStringSetValue(acNode hNode, const char* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts string nodes\n\n @param pValue\n  - Type: const char*\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acStringSetValue </B> sets a new value. New value must be shorter than the\n maximum value length (acStringGetMaxLength).\n\n @see\n  - acStringGetMaxLength"]
    pub fn acStringSetValue(hNode: acNode, pValue: *const ::std::os::raw::c_char) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acStringGetValue(acNode hNode, char* pValue, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts string nodes\n\n @param pValue\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Current value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acStringGetValue </B> retrieves the current value of the node."]
    pub fn acStringGetValue(
        hNode: acNode,
        pValue: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acStringGetMaxLength(acNode hNode, int64_t* pMaxLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts string nodes\n\n @param pMaxLen\n  - Type: int64_t*\n  - [Out] parameter\n  - Maximum length\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acStringGetMaxLength </B> retrieves the maximum length of the value\n string."]
    pub fn acStringGetMaxLength(hNode: acNode, pMaxLen: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acRegisterSet(acNode hNode, const uint8_t* pBuf, int64_t bufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts register nodes\n\n @param pBuf\n  - Type: const uint8_t*\n  - [In] parameter\n  - Buffer with the value to set\n\n @param bufLen\n  - Type: int64_t\n  - [In] parameter\n  - Length of buffer to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acRegisterSet </B> sets a register node's value."]
    pub fn acRegisterSet(hNode: acNode, pBuf: *const u8, bufLen: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acRegisterGet(acNode hNode, uint8_t* pBuf, int64_t bufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts register nodes\n\n @param pBuf\n  - Type: uint8_t*\n  - [Out] parameter\n  - Empty buffer to get the value\n\n @param bufLen\n  - Type: int64_t\n  - [In] parameter\n  - Length of the buffer to get\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acRegisterGet </B> gets a register node's value."]
    pub fn acRegisterGet(hNode: acNode, pBuf: *mut u8, bufLen: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCategoryGetNumFeatures(acNode hNode, size_t* pNumFeatures)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts category nodes\n\n @param pNumFeatures\n  - Type: size_t*\n  - [Out] parameter\n  - Number of features\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCategoryGetNumFeatures </B> retrieves the number of features of a\n category node."]
    pub fn acCategoryGetNumFeatures(hNode: acNode, pNumFeatures: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCategoryGetFeature(acNode hNode, size_t index, acNode* hFeatureNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts category nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the feature\n\n @param hFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Feature node (node of any type)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCategoryGetFeatureAndAccessMode </B> retrieves a feature node by its\n index."]
    pub fn acCategoryGetFeature(hNode: acNode, index: usize, hFeatureNode: *mut acNode)
        -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCategoryGetFeatureAndAccessMode(acNode hNode, size_t index, acNode* hFeatureNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts category nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the feature node\n\n @param hFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Feature node (node of any type)\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Feature node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCategoryGetFeatureAndAccessMode </B> retrieves a feature node and its\n access mode by its index."]
    pub fn acCategoryGetFeatureAndAccessMode(
        hNode: acNode,
        index: usize,
        hFeatureNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetNumEntries(acNode hNode, size_t* pNumEntries)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pNumEntries\n  - Type: size_t*\n  - [Out] parameter\n  - Number of entries\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetNumEntries </B> retrieves the number of entries."]
    pub fn acEnumerationGetNumEntries(hNode: acNode, pNumEntries: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryByIndex(acNode hNode, size_t index, acNode* phEntryNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryByIndex </B> retrieves an entry by its index."]
    pub fn acEnumerationGetEntryByIndex(
        hNode: acNode,
        index: usize,
        phEntryNode: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryAndAccessModeByIndex(acNode hNode, size_t index, acNode* phEntryNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Entry node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryAndAccessModeByIndex </B> retrieves an entry and its\n access mode by index."]
    pub fn acEnumerationGetEntryAndAccessModeByIndex(
        hNode: acNode,
        index: usize,
        phEntryNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetNumSymbolics(acNode hNode, size_t* pNumSymbolics)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pNumSymbolics\n  - Type: size_t*\n  - [Out] parameter\n  - Number of symbolics\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetNumSymbolics </B> retrieves the number of symbolics."]
    pub fn acEnumerationGetNumSymbolics(hNode: acNode, pNumSymbolics: *mut usize) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetSymbolicByIndex(acNode hNode, size_t index, char* pSymbolicBuf, size_t* pBufLen)\n\n )\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Entry of the node\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Symbolic of the entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetSymbolicByIndex </B> retrieves a symbolic by its entry's\n index."]
    pub fn acEnumerationGetSymbolicByIndex(
        hNode: acNode,
        index: usize,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationSetByIntValue(acNode hNode, int64_t value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param value\n  - Type: int64_t\n  - [In] parameter\n  - Integer value to set (from entry node)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationSetByIntValue </B> sets the entry by its integer value."]
    pub fn acEnumerationSetByIntValue(hNode: acNode, value: i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationSetBySymbolic(acNode hNode, const char* pSymbolic)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pSymbolic\n  - Type: const char*\n  - [In] parameter\n  - Symbolic to set (from entry node)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationSetBySymbolic </B> sets the entry of by its symbolic."]
    pub fn acEnumerationSetBySymbolic(
        hNode: acNode,
        pSymbolic: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryByName(acNode hNode, const char* pEntryName, acNode* phEntryNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pEntryName\n  - Type: const char*\n  - [In] parameter\n  - Name of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryByName </B> retrieves an entry by its name."]
    pub fn acEnumerationGetEntryByName(
        hNode: acNode,
        pEntryName: *const ::std::os::raw::c_char,
        phEntryNode: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryAndAccessModeByName(acNode hNode, const char* pEntryName, acNode* phEntryNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pEntryName\n  - Type: const char*\n  - [In] parameter\n  - Name of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Entry node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryAndAccessModeByName </B> retrieves an entry and its\n access mode by its name."]
    pub fn acEnumerationGetEntryAndAccessModeByName(
        hNode: acNode,
        pEntryName: *const ::std::os::raw::c_char,
        phEntryNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetCurrentEntry(acNode hNode, acNode* phEntryNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Current entry node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetCurrentEntry </B> retrieves the current entry."]
    pub fn acEnumerationGetCurrentEntry(hNode: acNode, phEntryNode: *mut acNode) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetCurrentEntryAndAccessMode(acNode hNode, acNode* phEntryNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Current entry node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Current entry node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetCurrentEntryAndAccessMode </B> retrieves the current entry\n and its access mode."]
    pub fn acEnumerationGetCurrentEntryAndAccessMode(
        hNode: acNode,
        phEntryNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetCurrentSymbolic(acNode hNode, char* pSymbolicBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Symbolic of the current entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetCurrentSymbolic </B> retrieves the current entry's\n symbolic."]
    pub fn acEnumerationGetCurrentSymbolic(
        hNode: acNode,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryGetIntValue(acNode hNode, int64_t* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pValue\n  - Type: int64_t*\n  - [Out] parameter\n  - Integer value of the entry\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryGetIntValue </B> retrieves the integer value of the enum entry."]
    pub fn acEnumEntryGetIntValue(hNode: acNode, pValue: *mut i64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryGetNumericValue(acNode hNode, double* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pValue\n  - Type: double*\n  - [Out] parameter\n  - Numeric value of the entry (if applicable)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryGetNumericValue </B> retrieves the numeric value of the enum\n entry (if applicable)."]
    pub fn acEnumEntryGetNumericValue(hNode: acNode, pValue: *mut f64) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryGetSymbolic(acNode hNode, char* pSymbolicBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Symbolic of the entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryGetSymbolic </B> retrieves the symbolic of the enum entry."]
    pub fn acEnumEntryGetSymbolic(
        hNode: acNode,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryIsSelfClearing(acNode hNode, bool8_t* pIsSelfClearing)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pIsSelfClearing\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the entry is self-clearing\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryIsSelfClearing </B> retrieves whether or not the enum entry is\n self-clearing."]
    pub fn acEnumEntryIsSelfClearing(hNode: acNode, pIsSelfClearing: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorIsSelector(acNode hNode, bool8_t* pIsSelector)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param pIsSelector\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is a selector\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves whether or not a node is a selector."]
    pub fn acSelectorIsSelector(hNode: acNode, pIsSelector: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetNumSelectingFeatures(acNode hNode, size_t* pNumSelectingFeatures)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param pNumSelectingFeatures\n  - Type: size_t*\n  - [Out] parameter\n  - Number of selecting features\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves the number of selecting features of a\n selector node."]
    pub fn acSelectorGetNumSelectingFeatures(
        hNode: acNode,
        pNumSelectingFeatures: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectingFeature(acNode hNode, size_t index, acNode* phSelectingFeatureNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the selecting feature\n\n @param phSelectingFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selecting feature (node of type enum entry)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selecting feature by its index."]
    pub fn acSelectorGetSelectingFeature(
        hNode: acNode,
        index: usize,
        phSelectingFeatureNode: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectingFeatureAndAccessMode(acNode hNode, size_t index, acNode* phSelectingFeatureNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the selecting feature\n\n @param phSelectingFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selecting feature (node of type enum entry)\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Selecting feature's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selecting feature and its access\n mode by its index."]
    pub fn acSelectorGetSelectingFeatureAndAccessMode(
        hNode: acNode,
        index: usize,
        phSelectingFeatureNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetNumSelectedFeatures(acNode hNode, size_t* pNumSelectedFeatures)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector node\n\n @param pNumSelectedFeatures\n  - Type: size_t*\n  - [Out] parameter\n  - Number of selected features\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves the number of selected features of a\n selector node."]
    pub fn acSelectorGetNumSelectedFeatures(
        hNode: acNode,
        pNumSelectedFeatures: *mut usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectedFeature(acNode hNode, size_t index, acNode* phSelectedFeatureNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the selected feature\n\n @param phSelectedFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selected feature (node of type enum entry)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selected feature by its index."]
    pub fn acSelectorGetSelectedFeature(
        hNode: acNode,
        index: usize,
        phSelectedFeatureNode: *mut acNode,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectedFeatureAndAccessMode(acNode hNode, size_t index, acNode* phSelectedFeatureNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of selected feature\n\n @param phSelectedFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selected feature (node of type enum entry)\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Selected feature's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selected feature and its access mode\n by its index."]
    pub fn acSelectorGetSelectedFeatureAndAccessMode(
        hNode: acNode,
        index: usize,
        phSelectedFeatureNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIDevFileStreamOpen(acIDevFileStream* phStream, acNodeMap hNodeMap, const char* pFileName)\n\n @param phStream\n  - Type: acIDevFileStream*\n  - [Out] parameter\n  - Pointer to the input file stream handle\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - Node map handle\n\n @param pFileName\n  - Type: const char*\n  - [In] parameter\n  - File name to open\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIDevFileStreamOpen </B> opens an input file stream for reading from camera memory."]
    pub fn acIDevFileStreamOpen(
        phStream: *mut acIDevFileStream,
        hNodeMap: acNodeMap,
        pFileName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIDevFileStreamRead(acIDevFileStream hStream, char* pBuffer, size_t count)\n\n @param hStream\n  - Type: acIDevFileStream\n  - [In] parameter\n  - Input file stream handle\n\n @param pBuffer\n  - Type: char*\n  - [Out] parameter\n  - Buffer to read data into\n\n @param count\n  - Type: size_t\n  - [In] parameter\n  - Number of bytes to read\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIDevFileStreamRead </B> reads data from the input file stream."]
    pub fn acIDevFileStreamRead(
        hStream: acIDevFileStream,
        pBuffer: *mut ::std::os::raw::c_char,
        count: usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIDevFileStreamFail(acIDevFileStream hStream, bool8_t* pFail)\n\n @param hStream\n  - Type: acIDevFileStream\n  - [In] parameter\n  - Input file stream handle\n\n @param pFail\n  - Type: bool*\n  - [Out] parameter\n  - True if the stream is in a failed state, false otherwise\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIDevFileStreamFail </B> checks if the input file stream is in a failed state."]
    pub fn acIDevFileStreamFail(hStream: acIDevFileStream, pFail: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIDevFileStreamClose(acIDevFileStream hStream)\n\n @param hStream\n  - Type: acIDevFileStream\n  - [In] parameter\n  - Input file stream handle\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIDevFileStreamClose </B> closes the input file stream."]
    pub fn acIDevFileStreamClose(hStream: acIDevFileStream) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acODevFileStreamOpen(\n     acODevFileStream* phStream,\n     acNodeMap hNodeMap,\n     const char* pFileName,\n     AC_O_DEV_FILE_STREAM_OPEN_MODE openMode)\n\n @param phStream\n  - Type: acODevFileStream*\n  - [Out] parameter\n  - Pointer to the output file stream handle\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - Node map handle\n\n @param pFileName\n  - Type: const char*\n  - [In] parameter\n  - Name of the file to open\n\n @param openMode\n  - Type: AC_O_DEV_FILE_STREAM_OPEN_MODE\n  - [In] parameter\n  - Open mode flags (combination of AC_O_DEV_FILE_STREAM_OPEN_MODE_LIST enum values)\n  - Use `AC_O_DEV_FILE_STREAM_OPEN_MODE_DEFAULT` for default mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns `AC_ERR_SUCCESS` (0) on success\n\n <B> acODevFileStreamOpen </B> opens an output file stream for writing data to the camera's local storage.\n"]
    pub fn acODevFileStreamOpen(
        phStream: *mut acODevFileStream,
        hNodeMap: acNodeMap,
        pFileName: *const ::std::os::raw::c_char,
        openMode: AC_O_DEV_FILE_STREAM_OPEN_MODE,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acODevFileStreamWrite(acODevFileStream hStream, const char* pBuffer, size_t count)\n\n @param hStream\n  - Type: acODevFileStream\n  - [In] parameter\n  - Output file stream handle\n\n @param pBuffer\n  - Type: const char*\n  - [In] parameter\n  - Buffer to write data from\n\n @param count\n  - Type: size_t\n  - [In] parameter\n  - Number of bytes to write\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acODevFileStreamWrite </B> writes data to the output file stream."]
    pub fn acODevFileStreamWrite(
        hStream: acODevFileStream,
        pBuffer: *const ::std::os::raw::c_char,
        count: usize,
    ) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acODevFileStreamFail(acODevFileStream hStream, bool8_t* pFail)\n\n @param hStream\n  - Type: acODevFileStream\n  - [In] parameter\n  - Output file stream handle\n\n @param pFail\n  - Type: bool*\n  - [Out] parameter\n  - True if the stream is in a failed state, false otherwise\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acODevFileStreamFail </B> checks if the output file stream is in a failed state."]
    pub fn acODevFileStreamFail(hStream: acODevFileStream, pFail: *mut bool8_t) -> AC_ERROR;
}
unsafe extern "C" {
    #[doc = " @fn AC_ERROR AC_API acODevFileStreamClose(acODevFileStream hStream)\n\n @param hStream\n  - Type: acODevFileStream\n  - [In] parameter\n  - Output file stream handle\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acODevFileStreamClose </B> closes the output file stream."]
    pub fn acODevFileStreamClose(hStream: acODevFileStream) -> AC_ERROR;
}
