# Расчет координат блоков на кране

**Цель** - рассчитать глобальные координаты центров блоков, установленных на стреле крана. Расчет основан на длине и угле наклона каждой стрелы, а также на локальных координатах блоков относительно начала стрел.

Схема крана включает в себя:

- **Две стрелы:**
  - `main boom` — основная стрела, длина обозначается: $L_{boom(1)}$
  - `knuckle boom` — складная стрела, длина обозначается $L_{boom(2)}$
- **Шесть блоков:**
  - 1 блок — барабан лебедки, который стоит отдельно от стрел и его координаты будут определяться отдельно
  - 2-6 блоки — блоки на стрелах

![Alt text to image](/assets/algorithm/Crane1.png)

**Расчет подразделяется на следующие этапы:**  
1. Расчёт абсолютного угла наклона каждой стрелы
2. Определение начальной точки и конечной точки для каждой стрелы
3. Определение координаты точек блоков
4. Реализация (Пример)

## 1. Расчёт абсолютного угла наклона каждой стрелы

Поскольку каждая следующая стрела (звено) поворачивается относительно предыдущей, её ориентация в глобальной системе координат зависит от **накопленной суммы всех предыдущих углов**.

Исходные данные:  
$$\alpha = [\alpha_1, \alpha_2, \ldots, \alpha_n]$$ — массив углов между стрелами (в градусах), а для первой стрелы между стрелой и горизонтом

Эти углы снимаются с датчика и определяют, насколько повёрнута каждая стрела **относительно предыдущей**.  
  Например:
  - $\alpha_1$ — угол основной стрелы к горизонту,
  - $\alpha_2$ — угол второй стрелы относительно первой и т.д.

![Alt text to image](/assets/algorithm/angles.png)

### Формула для абсолютного угла наклона стрелы к горизонту:

$$
\alpha_{boom_i} = \left( \sum_{i=1}^{n} \alpha_{i} \right) - 180 \cdot (i - 1)
$$

Где:
- $i$ — номер стрелы (1, 2, ...),
- $\alpha_i$ — угол между $i$-й стрелой и предыдущей (в градусах), для первой между стрелой и горизонтом.
- $\alpha_{boom_i}$ — угол $i$-й стрелы относительно горизонта.

 
**Формула определения координат точки в повернутой системе координат**

Если повернутая система координат повёрнута **против часовой стрелки**, то угол берётся со знаком **плюс (+)**.   Если **по часовой стрелке** — со знаком **минус (−)**.

Формулы представленные ниже - являются формулой в общем виде, и она будет использоваться в расчетах далее.

$$
X_x(X_{x1}, Y_{x1}, \alpha_{boom_i}) = X_{x1} \cdot \cos(\alpha_{boom_i}) - Y_{x1} \cdot \sin(\alpha_{boom_i})  
$$
  
$$
Y_x(X_{x1}, Y_{x1}, \alpha_{boom_i}) = X_{x1} \cdot \sin(\alpha_{boom_i}) + Y_{x1} \cdot \cos(\alpha_{boom_i})
$$

$$
XY_x =
\begin{bmatrix}
X_x \\
Y_x
\end{bmatrix}
$$

Где 
- $X_{x1}, Y_{x1}$ - координаты в неповернутой СК 
- $\alpha_{boom_i}$ - абсолютный угол между i-стрелой и горизонтом  
- $X_x, Y_x$ - координаты в повернутой СК  
- $XY_x$ - переменная с координатами точки $x$ в повернутой СК  

## 2. Определение начальной точки и конечной точки для каждой стрелы:

Для расчета координат начала стрел, $XY_{start(i)}$ необходим следующий алгоритм : 

**1. Введем две составляющие $x_0$ и $w$.**

- Переменная $w$, которая расчитывается по формуле определения координат в повернутой системе координат со следующими входными данными: 

  - $l_{3,i}$ - горизонтальное смещение точки $A_i$ стрелы относительно точки $G_{i-1}$ (относительно ГСК для первой срелы) в соответствии с рисунком.
  - $l_{4,i}$ - вертикальное смещение точки $A_i$ стрелы относительно точки $G_{i-1}$ (относительно ГСК для первой срелы) в соответствии с рисунком.
  - $\alpha'_{boom_i}$ - необходимый угол
  - Вторая составляющая - $x_0$ 

![Alt text to image](/assets/algorithm/l3_l4.png)

**2. Рассчитаем $w$**

$$
w_x(l_{4,i}, -l_{3,i}, \alpha'_{boom_i}) = l_{4,i} \cdot \cos(\alpha'_{boom_i}) + l_{3,i} \cdot \sin(\alpha'_{boom_i})
$$

$$
w_y(l_{4,i}, -l_{3,i}, \alpha'_{boom_i}) = l_{4,i} \cdot \sin(\alpha'_{boom_i}) - l_{3,i} \cdot \cos(\alpha'_{boom_i})
$$

$$
w =
\begin{bmatrix}
w_x \\
w_y
\end{bmatrix}
$$

**3. Определим $x_0$ для первой и следующих стрел**

- Для **первой стрелы** ($i = 1$) начальная точка в нашем случае совпадает с ГСК:
  Для первой стрелы угол принимается за 90.

$$
x_0 =[0, 0] ; \quad \alpha'_{boom_i}=90^\circ 
$$

- Для **последующих стрел** ($i > 1$) начальная точка совпадает с концом предыдущей стрелы, то есть с точкой $G_{i-1}$:

$$
x_0 = G_{i-1} ; \quad \alpha'_{boom_i}=\alpha_{boom_{(i-1)}}
$$

**4. Определим координаты $XY_{start(i)}$**

$$XY_{start(i)} = x_0 + w $$


**5. Рассчитаем координаты $D_i$ и $G_i$ в ГСК и определим матрицу $Т$**

Для расчета коодинат $D_i$ и $G_i$ нам необходимы следующие величины 

  - $l_{1,i}$ - **вертикальное расстояние** от точки $D_i$ до точки $A_i$ (перпендикуляр от D до оси поворота стрелы) в соответсвии с рисунком
  - $l_{2,i}$ - **горизонтальное расстояние** от точки $D_i$ до точки $A_i$ (вдоль оси стрелы) в соответсвии с рисунком

![Alt text to image](/assets/algorithm/l1_l2.png)

- Точка **D** (начало стрелы):

$$
D_i = XY_{start(i)} + XY_x(-l_{(2,i)},\quad l_{(1,i)}, \quad\alpha_{boom(i)})
$$

- Точка **G** (конец стрелы):

$$
G_i = XY_{start(i)} + XY_x(L_{boom(i)} -l_{(2,i)},\quad l_{(1,i)}, \quad \alpha_{boom(i)})
$$

- Матрица **Т** - матрица, содержащая пары точек (D, G) для каждой стрелы.

$$
T =
\begin{bmatrix}
D_i  \\
G_i
\end{bmatrix}
$$

---
> Эти точки используются для построения трансформационной матрицы $T_i$, описывающей положение стрелы $i$ в пространстве, а также для определения координат всех объектов, расположенных на этой стреле.

## 3. Определение координаты точек блоков
Для определения кооординат точек блоков, нам неуобходимы будут: 
- $K_{lFx(i,j)}$ - признак, показывающий от какой точки брать координату: от конца или начала стрелы, где $i -$ номер стрелы, $j -$ номер блока. 
- $l_{F_x(i,j)}$ - перпендикулярное расстояние от блока до оси стрелы
- $l_{F_y(i,j)}$ - продольное расстояние (вдоль стрелы) от выбранной точки $K_{lFx}$ - (D или G) до проекции точки на ось стрелы 

![Alt text to image](/assets/algorithm/Flx_Fly.png)

Алгоритм следующий: 

1. Определение  $K_{lFx(i,j)}$
   
- Если $K_{lFx(i,j)} == "D"$ , то мы берем из массива T значения из **первой** строки для i-ой стрелы и j-блока, так как туда записывали $D_i$. Для упрощения **a** - индекс строки массива, для $"D"$ **a --> 1**

- Если $K_{lFx(i,j)} == "G"$ , то мы берем из массива T значения из **второй** строки для i-ой стрелы и j-блока, так как туда записывали $G_i$ Для упрощения **a** - индекс строки массива, для $"G"$ **a --> 2**

И считаем для каждого блока координаты по общей формул

$$
XY_{block(i,j)} = XY_x(l_{F_x(i,j)}, \quad l_{F_y(i,j)}, \quad \alpha_{boom(i)}) +  T_{a_i}
$$

$$
XY_{block(i,j)} =
\begin{bmatrix}
X_{block(i,j)} \\
Y_{block(i,j)}
\end{bmatrix}
$$

## Реализация (Пример)

## Входные данные

| Переменная         | Тип / Формат           | Описание                                                       |
|--------------------|------------------------|-----------------------------------------------------------------|
| $L_{boom(i)}$       | float (мм)             | Длина i-ой стрелы стрелы                                          |                                  |
| $\alpha_i$      | float (°)              | Угол между стрелами                    |        |            |
| $n$       |                int |         Количество стрел |     
| $i$     | int                 | Номер стрелы: `1` — `main boom`, `2` — `knuckle boom`          |
|$l_{1, i}$|float(мм)|**вертикальное расстояние** от точки $D_i$ до точки $A_i$ (перпендикуляр от D до оси поворота стрелы)|
|$l_{2, i}$|float(мм)|**горизонтальное расстояние** от точки $D_i$ до точки $A_i$ (вдоль оси).|
|$l_{3,i}$|float(мм)|горизонтальное смещение точки $A_i$ стрелы относительно точки $G_{i-1}$ (относительно ГСК для первой срелы) в соответствии с рисунком. |
|$l_{4,i}$|float(мм)|вертикальное смещение точки $A_i$ стрелы относительно точки $G_{i-1}$ (относительно ГСК для первой срелы) в соответствии с рисунком. |
|$j$|int|номер блока|
|$K_{lFx(i,j)}$|str|признак, показывающий от какой точки брать координату: от конца или начала стрелы|
|$l_{F_x(i,j)}$|float (мм)|перпендикулярное расстояние от блока до оси стрелы| 
|$l_{F_y(i,j)}$|float (мм)|продольное расстояние (вдоль стрелы) от выбранной точки $K_{lFx}$ - (D или G) до проекции точки на ось стрелы |


## Выходные данные

| Переменная     | Тип / Формат          | Описание                     |
| -----------    | --------------------- | ---------------------------- |
|$X_{block(i,j)}$|float(мм)              |Координата X i-го блока|
|$Y_{block(i,j)}$|float(мм)              |Координата Y i-го блока|


Исходные данные:
-
Исходные данные представлены для 5 блоков, без лебедки, так как для нее другой расчет 

```python
#alpha = [0, 23.783]            # Углы в градусах как в расчете у Вани
alpha = [74, 128]               # Углы в градусах
L_boom = [11200, 7984]          # Длины стрел (мм)
l1 = [0, 0]                     # вертикальное смещение точки D
l2 = [0, 0]                     # горизонтальное смещение точки D
l3 = [0, 0]                     # вертикальное смещение начала стрелы
l4 = [10330, 0]                 # горизонтальное смещение начала стрелы

# Размеры расположения блоков на стрелах
lFx = [308, 1433, -1120, 268, 140]  # мм 
lFy = [1090, 1743, 1005, 895, 0]   # мм
#lFx = [308, 1435, -1121, 267, 136]  # мм как в расчете у Вани
#lFy = [1100, 1730, 973, 860, -35]   # мм как в расчете у Вани
K_lFx = ["G", "D", "G", "G", "G"]   # привязка блока к D(начало стрелы) или G(конец стрелы)
boom_index = [1, 2, 2, 2, 2]        # к какой стреле относится блок (нумерация с 1)
```


Пример реализации в коде `Python`
-

![Alt text to image](/assets/algorithm/python.png)

```python

def XY_rotate(lx, ly, alpha):
    angle_rad = math.radians(alpha)
    x = lx * math.cos(angle_rad) - ly * math.sin(angle_rad)
    y = lx * math.sin(angle_rad) + ly * math.cos(angle_rad)
    return x, y

# ---------------------------
# 1. Число стрел
# ---------------------------
n = len(alpha)

# ---------------------------
# 2. Угол наклона к горизонту каждой стрелы (alpha_boom)
# ---------------------------
alpha_boom = []
for i in range(1, n + 1):
    alpha_boom.append(sum(alpha[:i]) - (i - 1) * 180)

# ---------------------------
# 3. Матрица T (D и G для каждой стрелы)
# ---------------------------
T = []
for i in range(1, n + 1):
    # Начало стрелы
    if i == 1:
        x0, y0 = 0, 0
        alpha_prime = 90
    else:
        x0, y0 = T[i - 2][1] 
        alpha_prime = alpha_boom[i - 2]

    wx, wy = XY_rotate(l4[i-1], l3[i-1], alpha_prime)
    XY_start = (x0 + wx, y0 + wy)

    # Точка D
    Dx, Dy = XY_rotate(-l2[i-1], l1[i-1], alpha_boom[i-1])
    D_point = (XY_start[0] + Dx, XY_start[1] + Dy)

    # Точка G
    Gx, Gy = XY_rotate(L_boom[i-1] - l2[i-1], l1[i-1], alpha_boom[i-1])
    G_point = (XY_start[0] + Gx, XY_start[1] + Gy)

    T.append((D_point, G_point))

# ---------------------------
# 4. Координаты блоков XY_block
# ---------------------------
XY_block = []
for idx in range(len(lFx)):
    boom_i = boom_index[idx] - 1
    if K_lFx[idx] == "D":
        base_point = T[boom_i][0]
    elif K_lFx[idx] == "G":
        base_point = T[boom_i][1]
    else:
        raise ValueError("Некорректное значение K_lFx")

    dx, dy = XY_rotate(lFx[idx], lFy[idx], alpha_boom[boom_i])
    XY_block.append((base_point[0] + dx, base_point[1] + dy))

# ---------------------------
# Вывод
# ---------------------------
logging.debug(f"Число стрел: {n}")
logging.info("-"*40)
logging.debug(f"Углы alpha_boom (град): {[round(a, 3) for a in alpha_boom]}")
logging.info("-"*40)
logging.debug("Матрица T (D, G):")
for i, (D, G) in enumerate(T, start=1):
    logging.debug(f"Стрела {i}: D={D}, G={G}")
logging.info("-"*40)
logging.debug("Координаты блоков XY_block:")
for i, coord in enumerate(XY_block, start=1):
    logging.debug(f"Блок {i}: {coord}")

#-------------------------------
plt.figure(figsize=(10, 8))
plt.title("Схема расположения стрел и блоков")
plt.xlabel("X координата (мм)")
plt.ylabel("Y координата (мм)")
plt.grid(True)
plt.axis('equal')  # Для одинакового масштаба по осям

# Стрелы
colors = ['blue', 'green']  
for i, (D, G) in enumerate(T):
    # Линия стрелы (от D до G)
    plt.plot([D[0], G[0]], [D[1], G[1]], color=colors[i], linewidth=2, label=f'Стрела {i+1}')
    
    # Начало стрелы (точка D)
    plt.scatter(D[0], D[1], color=colors[i], s=50, marker='s')

    # Конец стрелы (точка G)
    plt.scatter(G[0], G[1], color=colors[i], s=50, marker='s')
    
# Блоки
for i, (x, y) in enumerate(XY_block):
    plt.scatter(x, y, color='red', s=70, marker='o')
    plt.text(x, y, f'Блок {i+1}', fontsize=8)


plt.legend()
plt.show()
```
